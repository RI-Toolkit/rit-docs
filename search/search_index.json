{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Retirement Income Toolkit","text":"<p>Toolkit of R modules for researchers to use in modeling retirement and age care risks, simulating cash flows for a range of retirement and long-term care products including Australian government support for Age Pensions and Aged Care based on means-testing, pricing and quantifying risk for a range of finance and insurance products to finance retirement and aged care risks.</p>"},{"location":"#toolkit-modules","title":"Toolkit Modules","text":""},{"location":"#aggregate-mortality-simulation","title":"Aggregate Mortality Simulation","text":"<p>This module will produce future cohort mortality scenarios for a specified age group for input into cash flow simulation and valuation modules. Input will be the model selected and parameter estimates derived from other available R packages (StMoMo).  A range of aggregate mortality models will be included so users can select the preferred model:</p> <ul> <li>Lee-Carter</li> <li>Age-Period-Cohort</li> <li>Renshaw-Haberman, CBD</li> <li>Gaussian affine (2 and 3-factor models)</li> </ul> <p>Output will include:</p> <ul> <li>Future cohort mortality rates and survival probability curves at future dates for a specified age cohort (starting from age 50 to age 110) </li> <li>Initial age risk-adjusted survival probabilities using specified risk adjustment methods (with input parameters for risk adjustment) </li> <li>Sharpe ratio</li> <li>Wang transform</li> <li>Price of risk for factor models</li> <li>Distributions of future lifetimes along (with summary statistics including expected future lifetime, standard deviation of future lifetime, impact of uncertainty in mortality rates versus expected mortality rates and survival probabilities)</li> </ul>"},{"location":"#health-state-modeling","title":"Health State Modeling","text":"<p>This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). </p> <p>Models will include functional disability based on:</p> <ul> <li>Various ADL\u2019s (2+, 3+, cognitive decline) with recovery</li> <li>Joint health status </li> <li>Disability states based on core activities for Australian applications</li> </ul> <p>Output will include:</p> <ul> <li>Probability transition matrices for different starting ages derived from transition rates, with trends</li> <li>Expected transition rates and simulated future transition rates for stochastic simulations</li> </ul> <p>Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models.</p>"},{"location":"#economic-scenario-generator","title":"Economic Scenario Generator","text":"<p>Outputs are joint simulated scenarios over specified horizons (age 50 to 110 \u2013 60 years) for economic variables, distributions of simulated variables at differing horizons (10 years, 20 years, 50 years, 60 years). </p> <p>The R code will input the parameters for a selected model (VAR) and generate:</p> <ul> <li>Simulated (correlated) paths for all the variables to use in cash flow modeling + computing expected values</li> <li>Valuation of cash flows in the cash flow module</li> <li>Distributions of the variables at different horizons \u2013 5 years, 10 years, 30 years</li> <li>Distributions of values of assets in real terms (deflated by GDP, CPI) over different horizons to show the impact of real returns and uncertainty in returns on other assets (equities, cash, housing, rolling bonds).</li> </ul>"},{"location":"#cash-flow-simulation-pricing","title":"Cash Flow Simulation + Pricing","text":"<p>This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products.</p> <p>Retirement products include:</p> <ul> <li>Account-based pensions</li> <li>Life annuities</li> <li>Deferred life annuities</li> <li>Pooled annuities</li> <li>Long-term care insurance</li> <li>Care annuities</li> <li>Variable annuities with GMWB</li> <li>Reverse mortgages with NNEG</li> </ul> <p>Risk-adjusted expected cash flows are computed, and prices are determined based on specified assumptions. Models use Australian data for Australian applications initially. The module includes government age pension and aged care based on current means-testing.</p>"},{"location":"Aggregate%20Mortality/overview/","title":"Overview","text":"<p>There is a popular package in R, StMoMo, that is used for stochastic mortality modelling. It  includes functions that fit a wide range of age-period-cohort models such as the Lee-Carter,  Cairns-Blake-Dowd models and many others. These are typically used to forecast and simulate future mortality rates.</p> <p>The aggregate mortality module extends upon the StMoMo package by introducing the following functionalities:</p> <ul> <li>Adding methods for more accurate mortality estimation at older ages (rate completion)</li> <li>Transforming survival functions from the real world to the risk-free probability measure</li> <li>Distribution and quantile functions of a survival function</li> <li>Simulation plots of the survival function and expected curtate future lifetime for a cohort</li> </ul> <p>These functions will allow for more accurate mortality studies at older ages (90+) and the pricing of a diverse range of insurance products.</p> <p>This module should be used in tandem with the StMoMo package. Namely, the inputs of this module  will usually be the mortality rates outputted by the StMoMo package. A general overview of the  module and the sequence of function executions can be visualised by the flowchart below:</p> <p></p>"},{"location":"Aggregate%20Mortality/period_cohort/","title":"Period and Cohort Rates","text":"<p>Mortality rates are often presented in a period format where each column represents the mortality rates across ages for a particular calendar year. However, they can  also be expressed in a cohort format where each column is for a particular cohort. Cohort rates are more suitable for the pricing of insurance products, so this module  introduces two helper functions to convert between period and cohort mortality rates and one-year death probabilities.</p>"},{"location":"Aggregate%20Mortality/period_cohort/#period-to-cohort-rates","title":"Period to Cohort Rates","text":"<p>period2cohort(period_rates, ages, init_age = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 period_rates : matrix/array</p> <p> period mortality rates with age rows, calendar year columns</p> <p> (and simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of ages for <code>period_rates</code></p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> initial age of cohort (default smallest age)</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of cohort mortality rates with age rows, cohort columns (and simulation number</p> <p>\u00a0\u00a0\u00a0\u00a0  3rd dimension). The columns represent the cohort aged <code>init_age</code> in the corresponding year.</p> <p> Usage:</p> <pre><code># consider the male mortality rates from the data file 'mortality_AUS_data'\nperiod_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\n# convert to rates for cohort aged 55\ncohort_rates_55 &lt;- period2cohort(period_rates, ages, init_age = 55)\n</code></pre> <p>Note</p> <p>The conversions between period and cohort mortality rates will only return the upper triangle.</p>"},{"location":"Aggregate%20Mortality/period_cohort/#cohort-to-period-rates","title":"Cohort to Period Rates","text":"<p>cohort2period(cohort_rates)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 cohort_rates : matrix/array</p> <p> cohort mortality rates with age rows, cohort columns</p> <p> (and simulation number 3rd dimension)</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of period mortality rates with age rows, year columns </p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># consider the Kannisto completion method on male mortality rates\n# from the data file 'mortality_AUS_data'\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nfitted_ages &lt;- 76:90\ncompleted_rates &lt;- complete_old_age(AUS_male_rates, ages, old_ages,\nmethod = \"kannisto\", type = \"central\",\nfitted_ages = fitted_ages)\n# suppose these are rates for cohort starting at age 60\ncohort_rates_60 &lt;- completed_rates[as.character(60:130), ]\nperiod_rates &lt;- cohort2period(cohort_rates_60)\n</code></pre> <p>Note</p> <p>The conversions between period and cohort mortality rates will only return the upper triangle.</p>"},{"location":"Aggregate%20Mortality/rate_change/","title":"Mortality Rate Changing","text":"<p>Mortality rates can be expressed in different types, such as central death rates, 1-year death probabilities and force of mortality. Different mortality rate completion methods require different types of mortality rates so this module includes a helper function to change between the types of mortality rates.</p> <p>This module uses the following notation for an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\):</p> <ul> <li>\\(m_{x, y}^{(i)}\\): central death rate</li> <li>\\(q_{x, y}^{(i)}\\): 1-year death probability</li> <li>\\(\\mu_{x, y}^{(i)}\\): force of mortality</li> </ul> <p>Implementation assumes a constant force of mortality for fractional ages,  resulting in the following conversions:</p> <ul> <li>\\(q_{x, y}^{(i)} = 1 - e^{-\\mu_{x, y}^{(i)}}\\)</li> <li>\\(\\mu_{x, y}^{(i)} = m_{x, y}^{(i)}\\)</li> <li>\\(m_{x, y}^{(i)}  = -\\log(1 - q_{x, y}^{(i)})\\)</li> </ul>"},{"location":"Aggregate%20Mortality/rate_change/#mortality-rate-changing_1","title":"Mortality Rate Changing","text":"<p>rate2rate(rates, from, to)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 rates : matrix/array</p> <p> mortality rates with age rows, cohort/year columns</p> <p> (and simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 from : character</p> <p> input type of mortality rates: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p>\u00a0\u00a0\u00a0\u00a0 to : character</p> <p> desired output type of mortality rates: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of converted mortality rates with age rows, cohort/year columns </p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># consider the male mortality rates from the data file 'mortality_AUS_data'\ncentral_rates &lt;- mortality_AUS_data$rate$male\n# convert to 1-yr death probabilities\ndeath_prob &lt;- rate2rate(central_rates, from = \"central\", to = \"prob\")\n</code></pre>"},{"location":"Aggregate%20Mortality/rate_completion/","title":"Mortality Rate Completion","text":"<p>Mortality rates observed at old ages are affected by random fluctuations and hence, unreliable. To accommodate for this, different completion methods have been proposed to 'extrapolate'  more accurate mortality rates at older ages, and are implemented in this module.</p>"},{"location":"Aggregate%20Mortality/rate_completion/#wrapper-function","title":"Wrapper Function","text":"<p>The different completion methods can be incorporated into a wrapper function which  implements the chosen completion method.</p> <p>complete_old_age(rates, ages, old_ages, method = \"kannisto\", type = 'prob', closure_age = 130, years = NULL, ...)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 rates : matrix/array</p> <p> mortality rates with age rows, calendar year columns, (simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of ages for <code>rates</code></p> <p>\u00a0\u00a0\u00a0\u00a0 old_ages : vector</p> <p> vector of old ages to be completed for</p> <p>\u00a0\u00a0\u00a0\u00a0 method : character</p> <p> the completion method to be used. 'CK' for Coale-Kisker, 'DG' for Denuit and Goderniaux</p> <p> 'Kannisto' for Kannisto</p> <p>\u00a0\u00a0\u00a0\u00a0 type : character</p> <p> input and output type of mortality rates: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p>\u00a0\u00a0\u00a0\u00a0 closure_age : numeric</p> <p> maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>rates</code></p> <p>\u00a0\u00a0\u00a0\u00a0 ...</p> <p> additional arguments required for the chosen completion method</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of completed mortality rates with age rows, year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># consider the male mortality rates from the data file 'mortality_AUS_data'\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\n# first convert mortality rates to death probabilities\nAUS_male_qx &lt;- rate2rate(AUS_male_rates, from = \"central\", to = \"prob\")\n# completing mortality rates for old ages\nDG_q &lt;- complete_old_age(AUS_male_qx, ages, old_ages, method = \"DG\",\ntype = \"prob\")\nCK_q &lt;- complete_old_age(AUS_male_qx, ages, old_ages, method = \"CK\",\ntype = \"prob\")\nkannisto_q &lt;- complete_old_age(AUS_male_qx, ages, old_ages, method = \"kannisto\",\ntype = \"prob\", fitted_ages = 80:90)\n</code></pre>"},{"location":"Aggregate%20Mortality/rate_completion/#coale-and-kisker-method","title":"Coale and Kisker Method","text":"<p>The model proposed by Coale and Kisker (1990) is one of techniques used to complete mortality rates for old ages. The implementation follows Pitacco et al. (2009) and is based on the exponential age-specific rate of change of central death rates $$  k_{x, y}^{(i)} = \\log \\left( \\frac{m_{x, y}^{(i)}}{m_{x - 1, y}^{(i)}} \\right) . $$</p> <p>The model assumes that \\(k_{x, y}^{(i)}\\) is linear over some age \\(x = \\beta\\), so $$    k_{x, y}^{(i)} =  k_{\\beta, y}^{(i)} - (x - \\beta) s_y^{(i)} $$ where \\(s_y^{(i)}\\) can be calculated assuming that \\(k_{\\beta, y}^{(i)}\\) is calculated from empirical data. The central death rate can then be calculated for ages over \\(\\beta\\) by using $$   m_{x, y}^{(i)} = m_{\\beta, y}^{(i)} \\exp \\left( \\sum^x_{l = \\beta + 1} k_{l, y}^{(i)} \\right). $$ In the implementation, \\(\\beta + 1\\) is taken to be the smallest value in <code>old_ages</code>.</p> <p>coale_kisker(rates, ages, old_ages, type = 'central', closure_age = 130, m_end = 1, years = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 rates : matrix/array</p> <p> mortality rates with age rows, calendar year columns, (simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of ages for <code>rates</code> </p> <p>\u00a0\u00a0\u00a0\u00a0 old_ages : vector</p> <p> vector of old ages to be completed for. Must connect with <code>ages</code>, see details </p> <p>\u00a0\u00a0\u00a0\u00a0 type : character</p> <p> input and output type of mortality rates: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p>\u00a0\u00a0\u00a0\u00a0 closure_age : numeric </p> <p> maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 m_end : numeric/vector</p> <p> central death rate at maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>rates</code></p> <p> Details:</p> <p>\u00a0\u00a0\u00a0\u00a0 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect</p> <p> <code>closure_age</code> must be equal to the last age in <code>old_ages</code></p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of completed mortality rates with age rows, year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># consider the male mortality rates from the data file 'mortality_AUS_data'\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\ncompleted_rates &lt;- coale_kisker(AUS_male_rates, ages, old_ages, type = \"central\")\n</code></pre> <p>References:</p> <p>Coale, Ansley J. and Kisker, Ellen E. 1990 'Defects in data on old-age mortality in the United States: New procedures for calculating schedules and life tables at the higher ages,' Asian and  Pacific Population Forum, 4: 1-31</p> <p>Pitacco, Ermanno &amp; Denuit, Michel &amp; Haberman, Steven &amp; Olivieri, Annamaria. (2009). Modelling Longevity Dynamics for Pensions and Annuity Business. </p>"},{"location":"Aggregate%20Mortality/rate_completion/#denuit-goderniaux-method","title":"Denuit &amp; Goderniaux Method","text":"<p>The Denuit and Goderniaux method (Denuit &amp; Goderniaux, 2005) is a life table closing procedure based on a constrained log-quadratic regression of the form $$   \\log(q_{x, y}^{(i)}) = a_y^{(i)} + b_y^{(i)} x +    c_y^{(i)} x^2 + \\epsilon_{x,y}^{(i)} $$ where \\(\\epsilon_{x,y}^{(i)}\\) i.i.d  \\(N(0, \\sigma^2)\\). This is fitted on ages <code>start_fit_age</code>  and over for each year. A closure constraint (max age), generally set at 130 is imposed as well as an  inflexion constraint that makes the rate of mortality increase at older ages slow down. </p> <p>Smoothing can also be applied to the results using a simple geometric average on the estimates.</p> <p>denuit_goderniaux(rates, ages, old_ages, type = 'prob', closure_age = 130, start_fit_age = 75, smoothing = FALSE, years = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 rates : matrix/array</p> <p> mortality rates with age rows, calendar year columns, (simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of ages for <code>rates</code></p> <p>\u00a0\u00a0\u00a0\u00a0 old_ages : vector</p> <p> vector of old ages to be completed for. Must connect with <code>ages</code>, see details</p> <p>\u00a0\u00a0\u00a0\u00a0 type : character</p> <p> input and output type of mortality rates: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p>\u00a0\u00a0\u00a0\u00a0 closure_age : numeric</p> <p> maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 start_fit_age : numeric</p> <p> model is fitted to ages starting from this age</p> <p>\u00a0\u00a0\u00a0\u00a0 smoothing : logical</p> <p> set TRUE to apply smoothing to the completed rates</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>rates</code></p> <p> Details:</p> <p>\u00a0\u00a0\u00a0\u00a0 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect</p> <p> <code>closure_age</code> must be equal to the last age in <code>old_ages</code></p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of completed mortality rates with age rows, year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># consider the male mortality rates from the data file 'mortality_AUS_data'\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\n# first convert mortality rates to death probabilties\nAUS_male_qx &lt;- rate2rate(AUS_male_rates, from = \"central\", to = \"prob\")\ncompleted_qx &lt;- denuit_goderniaux(AUS_male_qx, ages, old_ages, type = \"prob\")\n# fit on ages 80:110 instead\ncompleted_qx_from_80 &lt;- denuit_goderniaux(AUS_male_qx, ages, old_ages, type = \"prob\", start_fit_age = 80)\n</code></pre> <p>References:</p> <p>Denuit, M. and Goderniaux A., 2005 'Closing and Projecting lifetables using log-linear models',  Bulletin of the Swiss Association of Actuaries p. 29-49</p>"},{"location":"Aggregate%20Mortality/rate_completion/#kannisto-method","title":"Kannisto Method","text":"<p>The Kannisto model proposed by Kannisto (1994) is based on the logistic model to close mortality rates for old ages. A model of the form $$ \\text{logit}(\\mu_{x, y}^{(i)}) = \\log(a_{y}^{(i)}) + b_{y}^{(i)} x $$</p> <p>is fitted on a set of fitted ages to obtain \\(a_{y}^{(i)}\\) and \\(b_{y}^{(i)}\\).  The force of mortality for older ages can then be extrapolated via $$ \\mu_{x, y}^{(i)} = \\frac{a_{y}^{(i)} \\exp \\left({b_{y}^{(i)}} \\right)}  {1 + a_{y}^{(i)} \\exp \\left({b_{y}^{(i)}} \\right)} $$</p> <p>The set of fitted ages tends to be near the tail end of ages where the mortality rates are more accurate.</p> <p>kannisto(rates, ages, old_ages, fitted_ages, type = 'force', closure_age = 130, years = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 rates : matrix/array</p> <p> mortality rates with age rows, calendar year columns, (simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of ages for <code>rates</code></p> <p>\u00a0\u00a0\u00a0\u00a0 old_ages : vector</p> <p> vector of old ages to be completed for. Must connect with <code>ages</code>, see details.</p> <p>\u00a0\u00a0\u00a0\u00a0 fitted_ages : vector</p> <p> vector of ages to fit initial model. Must connect with <code>old_ages</code>, see details. </p> <p>\u00a0\u00a0\u00a0\u00a0 type : character</p> <p> input and output type of mortality rates: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p>\u00a0\u00a0\u00a0\u00a0 closure_age : numeric</p> <p> maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>rates</code></p> <p> Details:</p> <p>\u00a0\u00a0\u00a0\u00a0 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect</p> <p> <code>closure_age</code> must be equal to the last age in <code>old_ages</code></p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of completed mortality rates with age rows, year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># consider the male mortality rates from the data file 'mortality_AUS_data'\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\n# fit model on tail end of ages where mortality is still accurate \nfitted_ages &lt;- 76:90\ncompleted_rates &lt;- kannisto(AUS_male_rates, ages, old_ages,\nfitted_ages, type = \"central\")\n</code></pre> <p>References:</p> <p>Kannisto, V. (1994). Development of oldest-old mortality, 1950-1990: Evidence from 28 devel- oped countries. Odense University Press.</p> <p>Antonio, Katrien, et al. The IA|BE 2020 Mortality Projection for the Belgian Population. 2020.</p>"},{"location":"Aggregate%20Mortality/rate_survival/","title":"Mortality Rate and Survival Function","text":"<p>So far, this module has looked at the force of mortality, central death rate and one-year death probability. These are all relevant over a one-year period to determine the probability an individual currently aged \\(x\\) will survive to age \\(x+1\\).</p> <p>Sometimes it might be of interest to look at the probability an individual survives for more than one year. Hence, this module uses \\(S_{x, y}^{(i)} (t)\\) to denote  the probability an individual aged \\(x\\) in calendar/cohort year \\(y\\) will survive  to age \\(x + t\\) for simulation \\(i\\), where \\(t \\geq 0\\). This survival probability can be calculated for a range of values of \\(t\\), giving rise to the idea of a  survival function.</p> <p>Mortality rates can be converted to survival probabilities by using the formula</p> \\[ S_{x, y}^{(i)} (t) =  \\begin{cases}     1 &amp; t = 0 \\\\     \\prod_{l=0}^{t-1} p_{x+l, y}^{(i)} &amp; t &gt; 0 \\end{cases} \\] <p>where \\(p_{x, y}^{(i)} = 1 - q_{x, y}^{(i)}\\) is the one-year survival probability.</p> <p>The conversions between mortality rates and survival probabilities are covered by two helper functions, one for each direction.</p>"},{"location":"Aggregate%20Mortality/rate_survival/#mortality-rate-to-survival-function","title":"Mortality Rate to Survival Function","text":"<p>rate2survival(rates, ages, from = 'prob', init_age = NULL, years = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 rates : matrix/array</p> <p> mortality rates with age rows, cohort/year columns</p> <p> (and simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of ages for <code>rates</code></p> <p>\u00a0\u00a0\u00a0\u00a0 from : character</p> <p> type of rate to be converted from: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> initial age for survival function to be calculated at (default smallest age)</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>rates</code></p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of associated survival function with survival time rows, cohort/year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># consider the Kannisto completion method on male mortality rates\n# from the data file 'mortality_AUS_data'\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nfitted_ages &lt;- 76:90\ncompleted_rates &lt;- complete_old_age(AUS_male_rates, ages, old_ages,\nmethod = \"kannisto\", type = \"central\",\nfitted_ages = fitted_ages)\n# compute survival function of an individual aged 55\nall_ages &lt;- 0:130\nsurv_func &lt;- rate2survival(completed_rates, ages = all_ages,\nfrom = 'central', init_age = 55)\n</code></pre>"},{"location":"Aggregate%20Mortality/rate_survival/#survival-function-to-mortality-rate","title":"Survival Function to Mortality Rate","text":"<p>survival2rate(surv, ages, to = 'prob', years = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 surv : matrix/array</p> <p> survival function with survival time rows, cohort/year columns</p> <p> (and simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of desired ages for the resulting mortality rates</p> <p>\u00a0\u00a0\u00a0\u00a0 to : character</p> <p> type of rate to be converted to: 'central' for central death rates,</p> <p> 'prob' for 1 year death probabilities, 'force' for force of mortality</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>surv</code></p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of associated mortality rates with age rows, cohort/year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># create survival function for an individual aged 55\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nfitted_ages &lt;- 76:90\ncompleted_rates &lt;- complete_old_age(AUS_male_rates, ages, old_ages,\nmethod = \"kannisto\", type = \"central\",\nfitted_ages = fitted_ages)\nall_ages &lt;- 0:130\nsurv_func &lt;- rate2survival(completed_rates, ages = all_ages,\nfrom = 'central', init_age = 55)\n# convert from P to Q measure survival function\n# see the section on risk neutral probability\nsurv_func_Q &lt;- survivalP2Q(surv_func, method = \"wang\", lambda = 1.5)\n# convert from survival function to mortality rates\ncentral_rates_Q &lt;- survival2rate(surv_func_Q, 55:130, to = 'central')\n</code></pre>"},{"location":"Aggregate%20Mortality/risk_neutral/","title":"Risk Neutral Probability","text":"<p>Real world survival probabilities are very useful for mortality studies.  However, they do not account for longevity risk - the financial risk that people live longer  than expected and are thus not suitable for the pricing of insurance products. Hence,  this module includes a function that transforms the real world (P world) survival function  to a risk neutral (Q world) survival function according to a risk-neutral principle following Tang &amp; Li (2021).</p> <p>To introduce the transformation methods used by this function, the following simplified  notation is used:</p> <ul> <li>\\(f^P(t)\\) or \\(f^Q(t)\\): probability density function (pdf)</li> <li>\\(F^P(t)\\) or \\(F^Q(t)\\): cumulative distribution function (cdf)</li> <li>\\(S^P(t)\\) or \\(S^Q(t)\\): survival function</li> </ul> <p>where \\(S^P(t) = 1 - F^P(t)\\) and \\(S^Q(t) = 1 - F^Q(t)\\). Note that these functions are applied on an individual aged \\(x\\) in year \\(y\\) for each  simulation \\(i\\).</p> <p>The first set of transformations are survival function distortions and are as follows:</p> <ul> <li> <p>Wang transform: \\(S^Q(t) = 1 - \\Phi(\\Phi^{-1}(1 - S^P(t)) - \\lambda) \\quad (\\lambda \\geq 0)\\)  where \\(\\Phi(x)\\) represents the cdf of a standard Gaussian distribution.</p> </li> <li> <p>Proportional hazard transform: \\(S^Q(t) = (S^P(t))^{\\frac{1}{\\lambda}} \\quad (\\lambda \\geq 1)\\)</p> </li> <li>Dual-power transform: \\(S^Q(t) = 1 - \\left(1 - S^P(t)\\right)^\\lambda \\quad (\\lambda \\geq 1)\\) </li> <li>Gini principle: \\(S^Q(t) = (1 + \\lambda)S^P(t) - \\lambda(S^P(t))^2 \\quad (0 \\leq \\lambda \\leq 1)\\) </li> <li>Denneberg's absolute deviation principle:  \\(S^Q(t) = \\begin{cases}             (1 + \\lambda)S^P(t), &amp; 0 \\leq S^P(t) &lt; 0.5 \\\\             \\lambda + (1 - \\lambda)S^P(t), &amp; 0.5 \\leq S^P(t) \\leq 1          \\end{cases}          \\quad (0 \\leq \\lambda \\leq 1)\\) </li> <li>Exponential transform: \\(S^Q(t) = \\frac{1 - e^{-\\lambda S^P(t)}}{1 - e^{-\\lambda}} \\quad (\\lambda &gt; 0)\\) </li> <li>Logarithmic transform: \\(S^Q(t) = \\frac{\\log(1 + \\lambda S^P(t))}{\\log(1 + \\lambda)} \\quad (\\lambda &gt; 0)\\)</li> </ul> <p>The remaining transformations are pdf distortions and are given by:</p> <ul> <li>Canonical valuation: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)} \\quad (\\lambda &gt; 0)\\)</li> <li>Esscher transform: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\mathbb{E}[e^{\\lambda t}]} =     \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)} \\quad (\\lambda &gt; 0)\\)</li> </ul> <p>We note that for the pdf distortions (univariate canonical valuation and esscher transforms), the risk-adjusted pdfs are identical.</p>"},{"location":"Aggregate%20Mortality/risk_neutral/#survival-function-risk-neutral-transformation","title":"Survival Function Risk-Neutral Transformation","text":"<p>survivalP2Q(StP, method, lambda)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 StP : matrix/array</p> <p> survival function under P-measure with survival time rows, cohort/year columns</p> <p> (and simulation number 3rd dimension)</p> <p>\u00a0\u00a0\u00a0\u00a0 method : character</p> <p> the distortion risk measure to be used, see details for more information</p> <p>\u00a0\u00a0\u00a0\u00a0 lambda : numeric</p> <p> parameter associated with the distortion risk measure</p> <p> Details:</p> <p> \"wang\": Wang Transform \\((\\lambda \\geq 0)\\)</p> <p> \"ph\": Proportional Hazard Transform \\((\\lambda \\geq 1)\\)</p> <p> \"dp\": Dual-power Transform \\((\\lambda \\geq 1)\\)</p> <p> \"gp\": Gini Principle \\((0 \\leq \\lambda \\leq 1)\\)</p> <p> \"dadp\": Denneberg's Absolute Deviation Principle \\((0 \\leq \\lambda \\leq 1)\\)</p> <p> \"exp\": Exponential Transform \\((\\lambda &gt; 0)\\)</p> <p> \"log\": Logarithmic Transform \\((\\lambda &gt; 0)\\)</p> <p> \"canon\": Univariate Canonical Valuation \\((\\lambda &gt; 0)\\)</p> <p> \"esscher\": Esscher Transform \\((\\lambda &gt; 0)\\)</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix/array of risk neutral survival function under specified Q-measure with survival time</p> <p>\u00a0\u00a0\u00a0\u00a0 rows, cohort/year columns (and simulation number 3rd dimension)</p> <p> Usage:</p> <pre><code># create survival function for an individual aged 55\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nfitted_ages &lt;- 76:90\ncompleted_rates &lt;- complete_old_age(AUS_male_rates, ages, old_ages,\nmethod = \"kannisto\", type = \"central\",\nfitted_ages = fitted_ages)\nall_ages &lt;- 0:130\nsurv_func &lt;- rate2survival(completed_rates, ages = all_ages,\nfrom = 'central', init_age = 55)\n# convert from P to Q measure survival function\nsurv_func_Q &lt;- survivalP2Q(surv_func, method = \"wang\", lambda = 1.5)\n</code></pre> <p> References:</p> <p>Sixian Tang &amp; Jackie Li (2021) Market pricing of longevity-linked securities, Scandinavian Actuarial Journal, 2021:5, 408-436, DOI: 10.1080/03461238.2020.1852105</p>"},{"location":"Aggregate%20Mortality/simulation/","title":"Simulating Life Paths","text":"<p>One-year death probabilities derived from previous sections can also be used to simulate life paths for a single individual or a particular cohort. Each individual or cohort will be alive at a  specified initial age, and deaths are sampled according to the one-year death probabilities  given at each age.</p> <p>When simulating for an individual, the function keeps track of their dead or alive status at each age. When simulating for a cohort, the number of people still alive at each age is recorded.</p>"},{"location":"Aggregate%20Mortality/simulation/#simulate-individual-life-path","title":"Simulate Individual Life Path","text":"<p>sim_indiv_path(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, n_sim = 10000, seed = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> integer denoting initial age of individual</p> <p>\u00a0\u00a0\u00a0\u00a0 sex : character</p> <p> character denoting the gender of individual, \"F\" for female and \"M\" for male</p> <p>\u00a0\u00a0\u00a0\u00a0 death_probs : vector</p> <p> vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be </p> <p> fitted on <code>mortality_AUS_data</code> to produce forecasted death probabilities for an individual </p> <p> starting at <code>init_age</code> in 2022</p> <p>\u00a0\u00a0\u00a0\u00a0 closure_age : numeric</p> <p> maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 n_sim : numeric</p> <p> integer denoting number of path simulations</p> <p>\u00a0\u00a0\u00a0\u00a0 seed : numeric</p> <p> integer to be used as the seed for simulation</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 a matrix where each row is a different path of the individual's dead (-1) or alive (0) status </p> <p>\u00a0\u00a0\u00a0\u00a0 across the years</p> <p>An example looks like: </p> \\[\\begin{pmatrix} 0 &amp; -1 &amp; -1 &amp; -1 &amp; \\ldots &amp; -1 \\\\ 0 &amp; 0 &amp; 0 &amp; -1 &amp; \\ldots &amp; -1 \\\\  &amp;  &amp;  \\vdots &amp; &amp; &amp; \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\ldots &amp; -1 \\\\ 0 &amp; 0 &amp; -1 &amp; -1 &amp; \\ldots &amp; -1 \\end{pmatrix}\\] <p>Note that the first column of the matrix will always be 0 as everyone is alive at the initial age, and the last column will always be -1, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). </p> <p> Usage:</p> <pre><code># Simulate life paths for females starting at age 60\nsim_indiv_path(init_age = 60, sex = \"F\")\n# Suppose we want to use period 1-yr death probabilities instead\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nAUS_male_qx &lt;- rate2rate(AUS_male_rates, from = \"central\", to = \"prob\")\nkannisto_q &lt;- complete_old_age(AUS_male_qx, ages, old_ages, method = \"kannisto\",\ntype = \"prob\", fitted_ages = 80:90)\n# Consider males aged 55 in the year 2018\nqx_55_2018 &lt;- kannisto_q[as.character(55:130), \"2018\"]\nsim_indiv_path(init_age = 55, sex = \"M\", death_probs = qx_55_2018)                         </code></pre>"},{"location":"Aggregate%20Mortality/simulation/#simulate-cohort-life-path","title":"Simulate Cohort Life Path","text":"<p>sim_cohort_path_realised(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000, n_sim = 10000, seed = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> integer denoting initial age of cohort</p> <p>\u00a0\u00a0\u00a0\u00a0 sex : character</p> <p> character denoting the gender of cohort, \"F\" for female and \"M\" for male</p> <p>\u00a0\u00a0\u00a0\u00a0 death_probs : vector</p> <p> vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be </p> <p> fitted on <code>mortality_AUS_data</code> to produce forecasted death probabilities for a cohort </p> <p> starting at <code>init_age</code> in 2022</p> <p>\u00a0\u00a0\u00a0\u00a0 closure_age : numeric</p> <p> maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 cohort : numeric</p> <p> integer denoting initial cohort size</p> <p>\u00a0\u00a0\u00a0\u00a0 n_sim : numeric</p> <p> integer denoting number of path simulations</p> <p>\u00a0\u00a0\u00a0\u00a0 seed : numeric</p> <p> integer to be used as the seed for simulation</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 a matrix where each row represents the number of individuals still alive from the given cohort </p> <p>\u00a0\u00a0\u00a0\u00a0 at each age. Each row is a different path of the same cohort.</p> <p>An example looks like: </p> \\[\\begin{pmatrix} 1000 &amp; 996 &amp; 991 &amp; 985 &amp; \\ldots &amp; 0 \\\\ 1000 &amp; 998 &amp; 993 &amp; 986 &amp; \\ldots &amp; 0 \\\\  &amp;  &amp;  \\vdots &amp; &amp; &amp; \\\\ 1000 &amp; 997 &amp; 994 &amp; 986 &amp; \\ldots &amp; 0 \\\\ 1000 &amp; 997 &amp; 992 &amp; 987 &amp; \\ldots &amp; 0 \\end{pmatrix}\\] <p>Note that the first column of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last column will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). </p> <p> Usage:</p> <pre><code># Simulate life paths for cohort of 1000 females starting at age 60\nsim_cohort_path_realised(init_age = 60, sex = \"F\")\n# Suppose we want to use period 1-yr death probabilities instead\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nAUS_male_qx &lt;- rate2rate(AUS_male_rates, from = \"central\", to = \"prob\")\nkannisto_q &lt;- complete_old_age(AUS_male_qx, ages, old_ages, method = \"kannisto\",\ntype = \"prob\", fitted_ages = 80:90)\n# Consider 100 males aged 55 in the year 2018\nqx_55_2018 &lt;- kannisto_q[as.character(55:130), \"2018\"]\nsim_cohort_path_realised(init_age = 55, sex = \"M\",\ndeath_probs = qx_55_2018, cohort = 100)                         </code></pre>"},{"location":"Aggregate%20Mortality/simulation/#simulate-expected-cohort-life-path","title":"Simulate Expected Cohort Life Path","text":"<p>sim_cohort_path_expected(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> integer denoting initial age of cohort</p> <p>\u00a0\u00a0\u00a0\u00a0 sex : character</p> <p> character denoting the gender of cohort, \"F\" for female and \"M\" for male</p> <p>\u00a0\u00a0\u00a0\u00a0 death_probs : vector</p> <p> vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be </p> <p> fitted on <code>mortality_AUS_data</code> to produce forecasted death probabilities for a cohort </p> <p> starting at <code>init_age</code> in 2022</p> <p>\u00a0\u00a0\u00a0\u00a0 closure_age : numeric</p> <p> maximum age</p> <p>\u00a0\u00a0\u00a0\u00a0 cohort : numeric</p> <p> integer denoting initial cohort size</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 vector of expected number of individuals still alive  from a given cohort at each age</p> <p>An example looks like: </p> \\[\\begin{pmatrix} 1000 &amp; 995 &amp; 989 &amp; 981 &amp; \\ldots &amp; 0 \\end{pmatrix}\\] <p>Note that the first entry of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last entry will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). </p> <p> Usage:</p> <pre><code># Simulate expected life path for cohort of 1000 females starting at age 60\nsim_cohort_path_expected(init_age = 60, sex = \"F\")\n# Suppose we want to use period 1-yr death probabilities instead\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nAUS_male_qx &lt;- rate2rate(AUS_male_rates, from = \"central\", to = \"prob\")\nkannisto_q &lt;- complete_old_age(AUS_male_qx, ages, old_ages, method = \"kannisto\",\ntype = \"prob\", fitted_ages = 80:90)\n# Consider 100 males aged 55 in the year 2018\nqx_55_2018 &lt;- kannisto_q[as.character(55:130), \"2018\"]\nsim_cohort_path_expected(init_age = 55, sex = \"M\",\ndeath_probs = qx_55_2018, cohort = 100)\n</code></pre>"},{"location":"Aggregate%20Mortality/stats_functions/","title":"Summary Statistics","text":"<p>This module includes a set of functions that output summary statistics for the survival functions  generated. These include: </p> <ul> <li> <p>distribution functions</p> </li> <li> <p>quantile function</p> </li> <li> <p>simulation plots (with confidence ranges)</p> </li> </ul>"},{"location":"Aggregate%20Mortality/stats_functions/#distribution-and-quantile-functions","title":"Distribution and quantile functions","text":"<p>psurv(surv_fun, surv_time)</p> <p>qsurv(surv_fun, surv_prob)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 surv_fun : vector</p> <p> survival function for a specific cohort/year with survival time rows</p> <p>\u00a0\u00a0\u00a0\u00a0 surv_time : vector</p> <p> vector of survival times</p> <p>\u00a0\u00a0\u00a0\u00a0 surv_prob : vector</p> <p> vector of survival probabilities</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 vector of probabilites (distribution) or survival times (quantile)</p> <p> Usage:</p> <pre><code># create survival function for an individual aged 55\nAUS_male_rates &lt;- mortality_AUS_data$rate$male\nages &lt;- mortality_AUS_data$age # 0:110\nold_ages &lt;- 91:130\nfitted_ages &lt;- 76:90\ncompleted_rates &lt;- complete_old_age(AUS_male_rates, ages, old_ages,\nmethod = \"kannisto\", type = \"central\",\nfitted_ages = fitted_ages)\nall_ages &lt;- 0:130\nsurv_func &lt;- rate2survival(completed_rates, ages = all_ages,\nfrom = 'central', init_age = 55)\n# take vector of survival function (consider year 2017)\nsurv_func_2017 &lt;- surv_func[, \"2017\"]\n# calculate probability of surviving 10 and 20 years\npsurv(surv_func_2017, c(10, 20))\n# calculating the 80% and 95% quantile survival time\nqsurv(surv_func_2017, c(0.8, 0.95))\n</code></pre>"},{"location":"Aggregate%20Mortality/stats_functions/#survival-function-simulation","title":"Survival Function Simulation","text":"<p>Given multiple simulation paths of a survival function, the survival function for a chosen year with confidence intervals can be generated.</p> <p>plot_surv_sim(surv_sim, init_age, target_year, level = 95, years = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 surv_sim : array</p> <p> survival function with survival time rows, cohort/year columns</p> <p> and simulation number 3rd dimension</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> integer denoting initial age of <code>surv_sim</code></p> <p>\u00a0\u00a0\u00a0\u00a0 target_year : numeric</p> <p> year for which the plot is made for</p> <p>\u00a0\u00a0\u00a0\u00a0 level : numeric</p> <p> desired confidence level (default 95%)</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>surv_sim</code></p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 plot of the survival function for the chosen year with confidence intervals</p> <p> Usage:</p> <pre><code># generate simulated rates with 'StMoMo'\n# install and load 'StMoMo' if the package is not loaded\n# fitting lee carter model on ages 55:89\nAUS_StMoMo &lt;- StMoMoData(mortality_AUS_data, series = \"male\")\nLC &lt;- lc(link = \"logit\") # lee carter model\nAUS_Male_Ini_Data &lt;- central2initial(AUS_StMoMo)\nages_fit &lt;- 55:89\nwxy &lt;- genWeightMat(ages = ages_fit, years = AUS_Male_Ini_Data$years, clip = 3)\nLC_fit &lt;- fit(LC, data = AUS_Male_Ini_Data, ages.fit = ages_fit, wxt = wxy)\n# simulating rates for next 100 years\nset.seed(1234)\nn_sim &lt;- 10\nLC_sim &lt;- simulate(LC_fit, nsim = n_sim, h = 100)\n# using kannisto method to complete rates\nyoung_ages &lt;- LC_sim$ages # 55:89\nold_ages &lt;- 90:130\nages &lt;- c(young_ages, old_ages)\nkannisto_sim &lt;- complete_old_age(rates = LC_sim$rates, ages = young_ages,\nold_ages = old_ages, fitted_ages = 80:89,\nmethod = \"kannisto\", type = \"central\")\n# create period survival function for individual aged 55\nsurv_sim &lt;- rate2survival(kannisto_sim, ages, from = \"central\")  plot_surv_sim(surv_sim, 55, 2050)\n</code></pre>"},{"location":"Aggregate%20Mortality/stats_functions/#expected-curtate-future-lifetime","title":"Expected Curtate Future Lifetime","text":"<p>It may also be worthwhile to look at the expected curtate future lifetime of individuals.  Historical and simulated future mortality rates will need to be merged together via the helper function <code>combine_hist_sim</code>, and <code>exp_cfl</code> calculates the expected curtate future lifetime. As there is uncertainty involved with simulating future mortality rates, the function <code>plot_exp_cfl</code> can generate a plot of expected curtate future lifetime with confidence intervals across years/cohorts.</p>"},{"location":"Aggregate%20Mortality/stats_functions/#combine-historical-and-simulated-rates","title":"Combine Historical and Simulated Rates","text":"<p>combine_hist_sim(rates_hist, rates_sim)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 rates_hist : matrix</p> <p> historical mortality rates with age rows and cohort/year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 rates_sim : array</p> <p> simulated mortality rates with age rows, cohort/year columns</p> <p> and simulation number 3rd dimension</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 array of combined historical and simulated rates with age rows, cohort/year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 and simulation number 3rd dimension</p>"},{"location":"Aggregate%20Mortality/stats_functions/#calculate-expected-curtate-future-lifetime","title":"Calculate Expected Curtate Future Lifetime","text":"<p>exp_cfl(qx, ages, init_age = NULL, years = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 qx : matrix/array</p> <p> 1-year death probabilities with age rows, cohort/year columns</p> <p> (and simulation number 3rd dimension</p> <p>\u00a0\u00a0\u00a0\u00a0 ages : vector</p> <p> vector of ages for <code>qx</code></p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> initial age to calculate expected curtate future lifetime</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> optional numeric vector of years for <code>qx</code></p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix of expected curtate future lifetime with simulation number rows</p> <p>\u00a0\u00a0\u00a0\u00a0 and cohort/year columns</p>"},{"location":"Aggregate%20Mortality/stats_functions/#plot-expected-curtate-future-lifetime","title":"Plot Expected Curtate Future Lifetime","text":"<p>plot_exp_cfl(exp_cfl_rates, years, level = 95)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 exp_cfl_rates : matrix</p> <p> simulated expected curtate future lifetime with simulation number rows and</p> <p> cohort/year columns</p> <p>\u00a0\u00a0\u00a0\u00a0 years : vector</p> <p> numeric vector of years for <code>exp_cfl_rates</code></p> <p>\u00a0\u00a0\u00a0\u00a0 level : numeric</p> <p> desired confidence level (default 95%)</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 plot of expected curtate future lifetime with confidence intervals across years/cohorts</p> <p> Usage:</p> <pre><code># generate simulated rates with 'StMoMo'\n# install and load 'StMoMo' if the package is not loaded\n# fitting lee carter model on ages 55:89\nAUS_StMoMo &lt;- StMoMoData(mortality_AUS_data, series = \"male\")\nLC &lt;- lc(link = \"logit\") # lee carter model\nAUS_Male_Ini_Data &lt;- central2initial(AUS_StMoMo)\nages_fit &lt;- 55:89\nwxy &lt;- genWeightMat(ages = ages_fit, years = AUS_Male_Ini_Data$years, clip = 3)\nLC_fit &lt;- fit(LC, data = AUS_Male_Ini_Data, ages.fit = ages_fit, wxt = wxy)\n# simulating rates for next 100 years\nset.seed(1234)\nn_sim &lt;- 10\nLC_sim &lt;- simulate(LC_fit, nsim = n_sim, h = 100)\n# using kannisto method to complete rates\nyoung_ages &lt;- LC_sim$ages # 55:89\nold_ages &lt;- 90:130\nages &lt;- c(young_ages, old_ages)\nrates_hist &lt;- mortality_AUS_data$rate$male[as.character(young_ages), ]\nyears_hist &lt;- as.numeric(colnames(rates_hist))\nyears_sim &lt;- LC_sim$years\nyears &lt;- c(years_hist, years_sim)\nkannisto_sim &lt;- complete_old_age(rates = LC_sim$rates, ages = young_ages,\nold_ages = old_ages, fitted_ages = 80:89,\nmethod = \"kannisto\", type = \"central\")\nkannisto_hist &lt;- complete_old_age(rates = rates_hist, ages = young_ages,\nold_ages = old_ages, fitted_ages = 80:89,\nmethod = \"kannisto\", type = \"central\")\n################# USAGE BEGINS HERE ################\n# combining\nkannisto_55_period &lt;- combine_hist_sim(rates_hist = kannisto_hist,\nrates_sim = kannisto_sim)\n# working with cohort starting from age 55\nkannisto_55 &lt;- period2cohort(period_rates = kannisto_55_period, ages = ages)\nkannisto_55_q &lt;- rate2rate(kannisto_55, from = \"central\", to = \"prob\")\nexp_cfl_kannisto &lt;- exp_cfl(qx = kannisto_55_q, ages = ages)\n# Expected curtate future lifetime can only be computed for\n# the earlier (complete) cohorts\nexp_cfl_kannisto_clean &lt;- exp_cfl_kannisto[, as.character(1970:2043)]\nplot_exp_cfl(exp_cfl_rates = exp_cfl_kannisto_clean, years = 1970:2043)\n</code></pre>"},{"location":"Economic%20Scenario%20Generator/cts_esg/","title":"Continuous-Time Generator","text":"<p>The continuous-time economic scenario generator simulates the trajectories of (in brackets are the <code>$names</code> of the output dataframes): </p> <p>(1) Australia zero-coupon bond rates maturing every quarter from 3 months up to 10 years, i.e., 0.25 years (<code>$maturity_1qtrs</code>), 0.5 years (<code>$maturity_2qtrs</code>), 0.75 years (<code>$maturity_3qtrs</code>), ..., 10 years (<code>$maturity_40qtrs</code>), </p> <p>(2) NSW home value index (<code>$house_index</code>), </p> <p>(3) S&amp;P/ASX200 price (<code>$stock_price</code>). </p> <p>The zero-coupon bond term structure is fitted using the arbitrage-free Nelson-Siegel model, while NSW home value index and S&amp;P/ASX200 price are assumed to be Geometric Brownian Motions that are correlated with the zero-coupon bond rates. Further details on model parameter estimation and forecast can be found in note (a) below. </p> <p>The independent-factor model assumes that the level, slope, and curvature of the risk-free rate are mutually independent, while the correlated-factor model assumes dependence among them. Simulations generated by the correlated-factor models are more volatile since more parameters are involved. Further suggestions on model selection can be found in section \"Choosing an Appropriate Model\" below. </p> <p>Denote \\(X^1\\) the level, \\(X^2\\) the slope, \\(X^3\\) the curvature of the risk-free rate, \\(X^4\\) the logged NSW home value index, \\(X^5\\) the logged S&amp;P/ASX200 price, and \\(W^1, \\cdots, W^5\\) the standard Brownian Motions. Under the real-world measure, the independent-factor model satisfies the following stochastic differential equations: </p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>while the correlated-factor model satisfies </p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>The <code>interest_rate</code> models return paths generated from the first 3 equations, while the <code>interest_house_stock</code> models return paths generated from all 5 equations. The vector  is interpreted as the mean vector,  is the mean-reversion matrix, and  is the covariance matrix. Estimation of these parameters are in note (a). </p> <p>The results are still depicted with the same simulation frequency options as the discrete case, but the calculations are based in continuous time. </p> <p>esg_afns_simulator(num_years = 5, num_paths = 10, frequency = 'month', perc_change = FALSE, type = 'independent', model = 'interest_rate',seed = NULL)</p> <p> Paramters:</p> <p>\u00a0\u00a0\u00a0\u00a0 num_years : numeric</p> <p> integer denoting number of years to forecast from 01-07-2021, default 5 years</p> <p>\u00a0\u00a0\u00a0\u00a0 num_paths : numeric</p> <p> integer denoting the number of simulation paths, default 10 paths</p> <p>\u00a0\u00a0\u00a0\u00a0 frequency : character</p> <p> 'year', 'quarter' or 'month' denoting the simulation frequency, default 'month'</p> <p>\u00a0\u00a0\u00a0\u00a0 perc_change : logical</p> <p> set TRUE for outputs to be expressed as period-by-period percent change, default FALSE. The reference level, i.e., the original values in the first output period, will be appended above the percentage changes for each variable and each trajectory. See note (b) below</p> <p>\u00a0\u00a0\u00a0\u00a0 type : character</p> <p> 'independent' or 'correlated' denoting whether the latent factors are independent of each other, default 'independent'</p> <p>\u00a0\u00a0\u00a0\u00a0 model : character</p> <p> 'interest_rate' or 'interest_house_stock' denoting the output variables, default 'interest_rate'</p> <p>\u00a0\u00a0\u00a0\u00a0 seed : numeric</p> <p> Specify the seed for simulations, no default</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 A list of 40 dataframes containing simulated interest rates from 01-07-2021 with maturities from 1 quarter up to 10 years if model is set to be <code>interest_rate</code>, or 42 dataframes containing interest rates, NSW house value index, S&amp;P/ASX200 closing prices if model is set to be <code>interest_house_stock</code>. Rows are the trajectories (e.g., <code>trajectory_1</code>), columns are the time steps (e.g., <code>2021-07-01</code>). See note (c) for explanations on the negativity of output values. </p> <p> Usage:</p> <pre><code># simulate 10 years of data \nsim &lt;- esg_afns_simulator(num_years = 10, num_paths = 10, frequency = 'year', type = 'independent', model = 'interest_house_stock', seed = 1)\n# suppose we wish to look at the 3-month zero-coupon bond rates\nsim$maturity_1qtrs\n# suppose we wish to look at the 5-year zero-coupon bond rates\nsim$maturity_20qtrs\n# NSW house value index \nsim$house_index\n# S&amp;P/ASX200 closing price \nsim$stock_price </code></pre> <p> Choosing an Appropriate Model:</p> <ul> <li> <p>Choosing between models <code>interest_rate</code> and <code>interest_house_stock</code>:  </p> <p>The <code>interest_house_stock</code> model assumes dependency between interest rates, stock prices, and house indexes. Therefore, this model takes a more holistic view on the movements of those financial variables. </p> <p>However, a drawback is that the simulated <code>interest_house_stock</code> paths will be more volatile than the <code>interest_rate</code> model, and the paths will take longer to revert to mean levels. </p> <p>If users' intended area of usage is not influenced by stocks and house prices, the <code>interest_rate</code> model would be a good choice. If, otherwise, comovements among the financial variables are deemed important, the <code>interest_house_stock</code> model is suggested. </p> </li> <li> <p>Choosing between \"independent\" and \"correlated\" factor models:</p> <p>The correlated-factor model assumes correlation among level, slope, and curvature of the interest rate term structure, while the independent-factor model does not. Note that stock prices and house indexes are always correlated with the interest rate. </p> <p>The correlated-factor model takes a more holistic view on the underlying term structure of interest. Meanwhile, \"correlated\" model generates more volatile simulations, and it takes longer to revert to mean levels. </p> </li> <li> <p>Choosing between discrete- and continuous-time models: </p> <p>The outputs are different for the two simulators, users should choose the model based on their objectives. </p> <p>The base time step for discrete-time model is one quarter, whereas there is no such as a base for continuous-time. For time steps smaller than one quarter, discrete-time model will interpolate the quarterly statistics, whereas the continuous-time model simply generates random noises for each specific time step. Consequently, for large time steps, the executing time for continuous-time models are shorter than the dicrete-time model. </p> </li> </ul> <p> Notes:</p> <p>(a) Procedure for parameter estimation: </p> <ul> <li> <p>Under the real-world measure, computed measurement equation and state transition equation. </p> </li> <li> <p>Applied Kalman filtering to estimate the parameters. The maximum likelihood estimators were obtained from the Nelder-Mead algorithm. </p> </li> </ul> <p>Procedure for forecasts: Used the state transition equation: </p> <p> </p> <p>Detailed R codes for parameter estimation can be found in the economic tutorial/economic. </p> <p>(b) Large values of percentage change can appear if the original forecasts are near-zero, or if the Gaussian noise is large, though with low probabilities. This happens especially for interest rates in the first few periods due to historical-low rates in 2021. </p> <p>(c) Negative simulated interest rates are allowed since the Arbitrage-Free Nelson Siegel model does not impose non-negativity constraints. On the other hand, the stock prices and home value indexes must be positive, since simulations were done using log transforms, which is an implicit assumption of Geometric Brownian Motions. </p> <p> References:</p> <p>Christensen, J. H., Diebold, F. X. &amp; Rudebusch, G. D. (2011), \u2018The affine arbitrage-free class of nelson\u2013siegel term structure models\u2019, Journal of Econometrics 164(1), 4\u201320.</p> <p>Christensen, J. H., Lopez, J. A. &amp; Rudebusch, G. D. (2015), \u2018Analytical formulas for the second moment in affine models with stochastic volatility\u2019.</p>"},{"location":"Economic%20Scenario%20Generator/discrete_esg/","title":"Discrete-Time Generator","text":"<p>The discrete-time economic scenario generator simulates the trajectories of 11 Australian economic and financial variables (in brackets are the <code>$names</code> of the output dataframes): </p> <p>(1) 3-month zero-coupon bond yields (<code>$zcp3m_yield</code>),</p> <p>(2) 10-year zero-coupon bond spread (<code>$zcp10y_spread</code>),</p> <p>(3) NSW home value index (<code>$home_index</code>),</p> <p>(4) NSW home rental yields (<code>$rental_yield</code>),</p> <p>(5) Australia GDP (<code>$GDP</code>),</p> <p>(6) Australia CPI (<code>$CPI</code>),</p> <p>(7) S&amp;P/ASX200 closing price (<code>$ASX200</code>),</p> <p>(8) Australian dollar trade-weighted index (<code>$AUD</code>),</p> <p>(9) Australia mortgage rate (<code>$mortgage_rate</code>),</p> <p>(10) NSW unemployment rate (<code>$unemployment_rate</code>),</p> <p>(11) Stochastic discount factors (<code>$discount_factors</code>).</p> <p>Factors (1)-(8) (in rates) were fitted using a Vector Autoregressive model (VAR), factors (9)-(10) were respectively expressed as a fixed margin over factors (1)-(2) due to strong correlations, while factor (11) is derived from the fitted VAR model with arbitrage-free assumptions. Further details on model parameter estimation and forecasts can be found in note (a) below. </p> <p>Vector Autoregression (VAR) is a regression of a time series where the ouput depends linearly on the past values of itself, and the past values of other variables, up to some specfied order: </p> <p></p> <p>where  </p> <ul> <li> <p> is the vector of economic variables,</p> </li> <li> <p> is the vector of intercepts,</p> </li> <li> <p> are coefficient matrices of size \\(n \\times n\\) with \\(n\\) being the number of economic variables and \\(p\\) the lags. </p> </li> <li> <p> is a vector of white noises. </p> </li> </ul> <p>The stochastic discount factor is defined as: </p> <p></p> <p>where  and  respectively denote the 3-month zero-coupon bond rates and white noises from the fitted VAR model, and  is the market price of risk process which is assumed to be affine over factors (1)-(8). </p> <p>esg_var_simulator(num_years = 5, num_paths = 10, frequency = 'quarter', perc_change = FALSE, return_sdf = TRUE, seed = NULL)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 num_years : numeric</p> <p> integer denoting number of years to forecast from 01-01-2021, default 5 years</p> <p>\u00a0\u00a0\u00a0\u00a0 num_paths : numeric</p> <p> integer denoting number of simulations to make for each variable, default 10 paths</p> <p>\u00a0\u00a0\u00a0\u00a0 frequency : character</p> <p> 'year', 'quarter' or 'month' denoting the simulation frequency, default 'quarter'. The base simulation time step is one quarter, Linear interpolation will be used if the required frequency is higher, whereas arithmetic average will be used if the frequency is lower.</p> <p>\u00a0\u00a0\u00a0\u00a0 perc_change : logical</p> <p> set TRUE for outputs to be expressed as period-by-period percent change, default FALSE. The reference level, i.e., the original values in the first output period, will be appended above the percentage changes for each variable and each trajectory. See note (b) below.</p> <p>\u00a0\u00a0\u00a0\u00a0 return_sdf : logical </p> <p> set TRUE to return the stochastic discount factors, default TRUE</p> <p>\u00a0\u00a0\u00a0\u00a0 seed : numeric</p> <p> Specify the seed for simulations, no default</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 A list of 10 dataframes containing simulated trajectories from 01-01-2021 of the 10 variables, or a list of 11 dataframes including the simulated stochastic discount factors if <code>return_sdf</code> is set TRUE. Rows are the trajectories (e.g., <code>trajectory_1</code>), columns are the time steps (e.g., <code>2021-01-01</code>). See note (c) for explanations on the negativity of output values. </p> <p> Usage:</p> <pre><code># simulate 10 years of data\nsim &lt;- esg_var_simulator(num_years = 10, num_paths = 10, frequency = 'year')\n# suppose we wish to look at the 3 months zero coupon bonds\nsim$zcp3m_yield\n# if we wanted a specific trajectory, say 3\nsim$zcp3m_yield[3,]\n</code></pre> <p> Notes:</p> <p>(a) Procedure for parameter estimation: </p> <ul> <li> <p>Transformed factors (3),(5)-(8) to continuously compounded growth rates, tested for correlation, causality, and stationarity. </p> </li> <li> <p>Found the optimal lag order for Vector Autoregression using AIC, SIC, HQC. </p> </li> <li> <p>Fitted the VAR model using ordinary least squares. This was followed by evaluation. </p> </li> <li> <p>Associated the stochastic discount factors with VAR factors and nominal bond prices, estimated the market price of risk parameters by minimising the sum of squared error. </p> </li> </ul> <p>Procedure for forecasts: Generated factors (1)-(8) using Vector Autoregression formula. From the generated paths and noises, derived stochastic discount factors. </p> <p>Detailed R codes for parameter estimation can be found in the economic tutorial/economic. </p> <p>(b) Large values of percentage change can appear if the original forecasts are near-zero, or if the Gaussian noise is large, though with low probabilities. This happens especially for interest rates in the first few periods due to historical-low rates in 2021. </p> <p>(c) Negative values for rate factors i.e., factors (1)(2)(4)(9)(10), are theoretically allowed as Vector Autoregression models assume that the noise follow a Gaussian distribution. Index factors, i.e., factors (3)(5)-(8), on the other hand, are all positive. </p> <p>(d) Choosing between discrete- and continuous-time models: </p> <ul> <li> <p>The outputs are different for the two simulators, users should choose the model based on their objectives. </p> </li> <li> <p>The base time step for discrete-time model is one quarter, whereas there is no such as a base for continuous-time. For time steps smaller than one quarter, discrete-time model will interpolate the quarterly statistics, whereas the continuous-time model simply generates random noises for each specific time step. Consequently, for large time steps, the executing time for continuous-time models are shorter than the dicrete-time model.</p> </li> </ul> <p> References:</p> <p>Daniel H Alai, Hua Chen, Daniel Cho, Katja Hanewald, and Michael Sherris. Developing equity release markets: Risk analysis for reverse mortgages and home reversions. North American Actuarial Journal, 18(1):217\u2013241, 2014.</p> <p>Andrew Ang and Monika Piazzesi. A no-arbitrage vector autoregression of term structure dynamics with macroeconomic and latent variables. Journal of Monetary economics, 50(4):745\u2013787, 2003.</p> <p>Andrew Ang, Monika Piazzesi, and Min Wei. What does the yield curve tell us about gdp growth? Journal of econometrics, 131(1-2):359\u2013403, 2006.</p>"},{"location":"Economic%20Scenario%20Generator/overview/","title":"Overview","text":"<p>To price a financial product/instrument that will have cashflows in the future,  the present time valuation requires a set of assumptions on different economic factors.  The purpose of this module is to simulate a set of 11 economic variables that will  characterise the economic envrionment for a specified amount of time into the future. </p> <p>The 10 economic factors that will be simulated are:</p> <ol> <li> <p>3-month zero-coupon yield,</p> </li> <li> <p>10-year zero-coupon spread,</p> </li> <li> <p>NSW hedonic house value index,</p> </li> <li> <p>NSW house rental yields,</p> </li> <li> <p>Australia GDP,</p> </li> <li> <p>Australia CPI,</p> </li> <li> <p>S&amp;P/ASX200 closing price,</p> </li> <li> <p>Australian dollar trade-weighted index,</p> </li> <li> <p>Australia mortgage rate,</p> </li> <li> <p>NSW unemployment rate,</p> </li> <li> <p>Stochastic discount factors (pricing kernels). </p> </li> </ol> <p>These 11 factors can provide a comprehensive picture of the economic environment in the  future, which is useful for projecting investments/financial products into the future, as well  as discounting future cash flows to more accurately gauge present value. This allows for broad appliations in insurance pricing, loan/debt pricing, and project valuations.</p> <p>The module has a discrete-time economic scenario generator (ESG), and a continuous-time ESG. The discrete-time ESG is fit on discrete time intervals, whereas continuous-time ESG's can in theory be fit for any time  point. However, the module uses the same simulation frequencies for both ESG types. </p>"},{"location":"Economic%20Scenario%20Generator/summary_esg/","title":"Summary statistics","text":"<p>Period-by-period summary statistics such as quantiles, mean, and standard deviation are helpful in understanding the distribution of the simulated trajectories. We provide a R function which accepts a list or a dataframe of time series data, and returns various common choices of summary statistics. </p> <p>esg_summary(paths, probs = seq(0, 1, 0.25), na.rm = TRUE)</p> <p> Paramters:</p> <p>\u00a0\u00a0\u00a0\u00a0 paths : a list or a dataframe</p> <p> List or dataframe containing time series data</p> <p>\u00a0\u00a0\u00a0\u00a0 probs : numeric or vector </p> <p> Numeric vector of probabilities with values in [0,1]. Default is 0%, 25%, 50%, 75%, 100%-tiles</p> <p>\u00a0\u00a0\u00a0\u00a0 rm.na : logical</p> <p> set TRUE if any NA and NaN's are removed from data before computing the statistics. Default TRUE</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 List of dataframe containing summary statistics for each period across trajectories. </p> <p> Usage:</p> <pre><code># simulate 10 years of data \nsim &lt;- esg_var_simulator(num_years = 10, num_paths = 10, frequency = 'year')\n# obtain summary statistics for GDP data with default statistics\ngdp_summ &lt;- esg_summary(sim$GDP) # obtain summary statistics for 0%,20%,40%,60%,80%,100%-tiles for the whole list \nall_summ &lt;- esg_summary(sim, probs = seq(0,1,0.2))\n# summary statistics for self-defined dataframes \ntest_data = as.data.frame(matrix(1:100, nrow = 4, byrow = TRUE))\ntest_data2 = as.data.frame(matrix(1001:2000, nrow = 40, byrow = TRUE))\ntest_list = list(test_data, test_data2)\nesg_summary(test_list)\n</code></pre>"},{"location":"Health/lifetable/","title":"Life Table Generation","text":"<p>An individual's characteristics can also be used to generate a life table with a cohort of identical traits. This can be used to calculate the probability of survival to different states.</p> <p>Life tables generated from the static and trend models are always deterministic, so the output will be one lifetable.</p> <p>Meanwhile, the frailty model will produce stochastic outputs. The lifetables outputted will be  a full list of the simulated lifetables. </p> <p>The lifetable shows the number of people in each state at each age, and one can also choose the initial state and the initial age that the starting cohort is in.</p>"},{"location":"Health/lifetable/#generating-a-life-table-for-static-and-trend-models","title":"Generating a Life Table for Static and Trend Models","text":"<p>create_life_table(trans_probs, init_age, init_state = 0, cohort = 100000)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 trans_probs : list</p> <p> list of transition probability matrices; typically generated by 'get_trans_probs'</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 * numeric denoting initial age of individual*</p> <p>\u00a0\u00a0\u00a0\u00a0 init_state : numeric</p> <p> for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state </p> <p> for 5-state model: 0 for H state, 1 for M state, 2 for D state, 3 for MD state </p> <p>\u00a0\u00a0\u00a0\u00a0 cohort : numeric</p> <p> number of people at the beginning of the life table</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 a list of life table matrices</p> <p> Usage: <pre><code># for male aged 65 at wave index i, initially in the health state, using the static model with parameters 'params'\ntrans_probs &lt;- get_trans_probs(n_states=5, model_type='S', param_file=US_HRS_5, init_age=65, female=0, year = 2012, wave_index = 8, latent = 0)\nlifetable &lt;- create_life_table(trans_probs, init_age=65, init_state = 0, cohort = 100000)\n</code></pre></p>"},{"location":"Health/lifetable/#simulating-a-number-of-life-tables-for-frailty-model","title":"Simulating a Number of Life Tables for Frailty Model","text":"<p>simulate_life_table(n_states, model_type, param_file, init_age, female, year = 2012, init_state = 0, wave_index = 8,latent=0,n_sim=100,cohort=100000,mean=FALSE)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 n_states : numeric</p> <p> take values 3 or 5, use 3 for 3-state model, and 5 for 5-state model</p> <p>\u00a0\u00a0\u00a0\u00a0 model_type : character</p> <p> select F for Frailty model</p> <p>\u00a0\u00a0\u00a0\u00a0 param_file : dataframe</p> <p> File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS for the 3-state model, and use US_HRS_5 for the 5-state-model)</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> integer denoting the initial age</p> <p>\u00a0\u00a0\u00a0\u00a0 female : numeric</p> <p> 0 for male, 1 for female</p> <p>\u00a0\u00a0\u00a0\u00a0 year : numeric</p> <p> integer denoting current year, required in 3-state model and ignored in 5-state model</p> <p>\u00a0\u00a0\u00a0\u00a0 init_state : numeric</p> <p> for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state </p> <p>\u00a0\u00a0\u00a0\u00a0 wave_index : numeric</p> <p> integer for the wave index = (interview year - 1998)/2 + 1, required in 5-state model and ignored in 3-state model</p> <p>\u00a0\u00a0\u00a0\u00a0 latent : numeric</p> <p> initial value of latent factor, normally take the value 0</p> <p>\u00a0\u00a0\u00a0\u00a0 n_sim : numeric</p> <p> integer denoting number of life table simulations</p> <p>\u00a0\u00a0\u00a0\u00a0 cohort : numeric</p> <p> number of people at the beginning of the life table</p> <p>\u00a0\u00a0\u00a0\u00a0 mean : logic</p> <p> TRUE to return expected life table, FALSE to return all simulated life tables</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 a list of life table matrices</p> <p> Usage:</p> <pre><code># for male aged 65 at wave index i, initially in the health state, using the frailty model with parameters 'params'\nlifetable_simulated &lt;- simulate_life_table(n_states=5, model_type='F', param_file=US_HRS_5, init_age=65, female=0, year = 2012, init_state = 0, wave_index = 8,latent=0,n_sim=100,cohort=100000,mean=FALSE)\n</code></pre>"},{"location":"Health/overview/","title":"Overview","text":"<p>This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). </p> <p>Models will include functional disability based on:</p> <ul> <li>Various ADL\u2019s (2+, 3+, cognitive decline) with recovery</li> <li>Joint health status </li> <li>Disability states based on core activities for Australian applications</li> </ul> <p>Output will include:</p> <ul> <li>Probability transition matrices for different starting ages derived from transition rates, with trends</li> <li>Expected transition rates and simulated future transition rates for stochastic simulations</li> </ul> <p>Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models.</p>"},{"location":"Health/simulation/","title":"Simulating Life Paths","text":"<p>Expected values are easily derived from the transition probabilities, but some form of  simulation is required to analyse variance of risks. Simulation can be performed by using the transition probability matrices. </p> <p>Everyone starts in a certain health state, and we sample movements according to  the probabilities given at each age. Death state, -1, is absorbing. The other states are:</p> <p>3-state model:</p> <ul> <li> <p>0: healthy</p> </li> <li> <p>1: disabled</p> </li> </ul> <p>5-state model:</p> <ul> <li> <p>0: healthy</p> </li> <li> <p>1: ill health but not functionally disabled</p> </li> <li> <p>2: good health but functionally disabled</p> </li> <li> <p>3: ill health and functionally disabled</p> </li> </ul>"},{"location":"Health/simulation/#simulating-state-paths-for-individuals","title":"Simulating State Paths for Individuals","text":"<p>simulate_health_state_paths(trans_probs, init_age, init_state = 0, cohort = 10000)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 trans_probs : list</p> <p> list of transition probability matrices; typically generated by 'get_trans_probs'</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> integer denoting initial age of individual</p> <p>\u00a0\u00a0\u00a0\u00a0 init_state : numeric</p> <p> for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state </p> <p> for 5-state model: 0 for H state, 1 for M state, 2 for D state, 3 for MD state </p> <p>\u00a0\u00a0\u00a0\u00a0 cohort : numeric</p> <p> integer denoting number of people in the simulation</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 matrix (see below for details)</p> <p> Usage:</p> <pre><code># simulation for 10000 males aged 65, initially healthy under the static model\ntrans_probs &lt;- get_trans_probs(n_states=5, model_type='S', param_file=US_HRS_5, init_age=65, female=0, year = 2012, wave_index = 8, latent = 0)\nsimulated_path &lt;- simulate_health_state_paths(trans_probs, init_age=65, init_state = 0, cohort = 10000)\n</code></pre> <p>The output is a matrix where each row represents one individual's transition into different  states at each year of their life. </p> <p>An example looks like: </p> \\[\\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 1 &amp; \\ldots &amp; -1\\\\ 0 &amp; 0 &amp; 2 &amp; 2 &amp; \\ldots &amp; 3 \\\\  &amp;  &amp;  \\vdots &amp; &amp; &amp; \\\\ 0 &amp; -1 &amp; -1 &amp; -1 &amp; \\ldots &amp; -1 \\\\ 0 &amp; 0 &amp; 3 &amp; 2 &amp; \\ldots &amp; 2 \\end{bmatrix}\\] <p>Note</p> <p>The first column of the matrix will always be initial state provided in the parameters.</p>"},{"location":"Health/trans_probs/","title":"Transition Probability Matrix","text":"<p>The Cox Hazard model produces continuous hazard rates that will be discretized to produce piecewise constant rates. </p> <p>The process is repeated for each of the transition rates (4 transitions for 3-state model, and 12 transitions for 5-state model). The rates at each age are combined into transition rate matrices for that age. Taking the matrix exponential changes that to  transition probability matrices. </p> <p>Note</p> <p>The transition probability matrices are deterministic for each individual  with the Static and Trend models, but stochastic with the Frailty model.</p>"},{"location":"Health/trans_probs/#get-a-list-of-transition-probability-matrices-from-initial-age-to-age-110","title":"Get a List of Transition Probability Matrices from Initial Age to Age 110","text":"<p>get_trans_probs(n_states, model_type, param_file, init_age, female, year = 2012, wave_index = 8, latent = 0)</p> <p> Parameters</p> <p>\u00a0\u00a0\u00a0\u00a0 n_states : numeric</p> <p> take values 3 or 5, use 3 for 3-state model, and 5 for 5-state model</p> <p>\u00a0\u00a0\u00a0\u00a0 model_type : character</p> <p> 'S' for static model, 'T' for trend model, 'F' for frailty model</p> <p>\u00a0\u00a0\u00a0\u00a0 param_file : dataframe</p> <p> File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS for the 3-state model, and use US_HRS_5 for the 5-state-model)</p> <p>\u00a0\u00a0\u00a0\u00a0 init_age : numeric</p> <p> integer denoting the initial age</p> <p>\u00a0\u00a0\u00a0\u00a0 female : numeric</p> <p> 0 for male, 1 for female</p> <p>\u00a0\u00a0\u00a0\u00a0 year : numeric</p> <p> integer denoting current year, required in 3-state model and ignored in 5-state model</p> <p>\u00a0\u00a0\u00a0\u00a0 wave_index : numeric</p> <p> integer for the wave index = (interview year - 1998)/2 + 1, required in 5-state model and ignored in 3-state model</p> <p>\u00a0\u00a0\u00a0\u00a0 latent : numeric</p> <p> initial value of latent factor, normally take the value 0</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 List of 3x3 or 5x5 transition probability matrices, from the initial age to age 110.</p> <p> Usage:</p> <pre><code># for male aged 65 at wave index i, using the 5-state frailty model with US_HRS_5 parameters\ntrans_probs=get_trans_probs(n_states=5, model_type='F', param_file=US_HRS_5, init_age=65, female=0, year = 2012, wave_index = 8, latent = 0)\n</code></pre>"},{"location":"Health/workflow/","title":"Workflow Example","text":"<p>The following is an example of the general workflow of the module. It demonstrates the order of function executions, and the different endpoint outputs. We use the following individual characteristics:</p> <ul> <li>male</li> <li>age 87</li> <li>initial year 2022</li> <li>trend model </li> <li>healthy </li> <li>use parameters estimated from the US study: <code>US_HRS</code> for 3-state model and <code>US_HRS_5</code> for 5-state model</li> </ul> <p><pre><code># first we create a list of transition probability matrices \ntrans_probs_3 &lt;- get_trans_probs(n_states=3, model_type='T', param_file=US_HRS, init_age=87, female=0, year = 2022, latent = 0)\n# using the transition probabilities, we can generate life tables\nlifetable &lt;- create_life_table(trans_probs_3, init_age=87, init_state = 0, cohort = 100000)\nhead(lifetable)\n</code></pre> Life table generated for 3-state models:</p> <p></p> <p><pre><code># can also create a plot of mortality and disability curves\nprob_plots(init_state = 0, 87, trans_probs_3)\n</code></pre> Plot of survival probabilities to different states for 3-state models:</p> <p></p> <p>Statistics for 3-state models: <pre><code># from transition probabilities, we can simulate lifetime paths\nsim_paths_3 &lt;- simulate_health_state_paths(trans_probs_3, init_age=87, init_state = 0, cohort = 10000)\n# all survival statistics (mean and standard deviation): \nhealth_stats(n_states=3, init_age=87, init_state=0, trans_probs=trans_probs_3)\n</code></pre></p> <p></p> <p>Workflow for 5-state models: <pre><code># first we create a list of transition probability matrices for the 5-state model\ntrans_probs_5 &lt;- get_trans_probs(n_states=5, model_type='T', param_file=US_HRS_5, init_age=87, female=0, year = 2012, wave_index = 13, latent = 0)\n# using the transition probabilities, we can generate life tables\nlifetable_5 &lt;- create_life_table(trans_probs_5, init_age=87, init_state = 0, cohort = 100000)\n# from transition probabilities, we can simulate lifetime paths\nsimulated_path_5 &lt;- simulate_health_state_paths(trans_probs_5, init_age=87, init_state = 0, cohort = 10000)\n# can also create a plot of surviving probabilities to different states\nprob_plots(init_age=87, init_state = 0, trans_probs_5)\n# all survival statistics (mean and standard deviation):\nhealth_stats(n_states=5, init_age=87, init_state=0, trans_probs=trans_probs_5)\n</code></pre> Life table generated for 5-state models:</p> <p></p> <p>Plot of survival probabilities to different states for 5-state models:</p> <p></p> <p>Statistics for 5-state models:</p> <p></p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/","title":"3-State Model","text":""},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#general-principle","title":"General Principle","text":"<p>The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for  an individual \\(k\\) and transition type \\(s\\) is: </p> \\[\\lambda_{k, s}(t) = \\text{exp}(\\boldsymbol{\\beta}_{s}'\\mathbf{X}_k) \\cdot H_{k, s}(t)\\] <p>In the above forumlation, \\(\\boldsymbol{\\beta}\\) contains coefficients of transition type \\(s\\) to be estimated, and \\(\\mathbf{X}\\) contains the covariates of individual \\(k\\). Furthermore, we assume the  Markovaian property where \\(H_{k, s}(t) = 1\\). </p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#three-models","title":"Three Models","text":""},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#static-model","title":"Static Model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t)  + \\gamma^{\\text{female}}_s F_k \\] <p>where \\(x_k(t)\\) represents the age for the \\(k\\)th individual at time t and \\(F_k = 1\\) if the \\(k\\)th individual is female. The coefficients are parameters to be estimated.</p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#trend-model","title":"Trend Model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t)  + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t \\] <p>where \\(t\\) is the time trend. Note that \\(t=1\\) corresponds to the year 1998-1999. </p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#frailty-model","title":"Frailty Model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t)  + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t + \\alpha_s \\psi(t) \\] <p>where \\(\\psi(t)\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi(t) = \\psi(t-1) + \\epsilon\\) with \\(\\epsilon \\sim \\text{N}(0, 1)\\).</p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#parameters","title":"Parameters","text":"<p>The module uses cox hazard model parameters estimated from external research studies. The parameters of the two following studies are included in the package: </p> <ul> <li> <p>US Health and Retirement Study (parameter name: US_HRS)</p> </li> <li> <p>China Chinese Longitudinal Healthy Longevity Survey (parameter name: china_CLHLS)</p> </li> </ul>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/","title":"5-State Model","text":""},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#general-principle","title":"General Principle","text":"<p>The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for  an individual \\(k\\) and transition type \\(s\\) is: </p> \\[\\lambda_{k, s}(t)=\\exp \\left\\{\\beta_{s}+\\gamma_{s}^{\\prime} w_{k}(t)+\\alpha_{s} \\psi(t)\\right\\}\\] <p>In the above forumlation, \\(\\beta_{s}\\) is the baseline log-intensity for transition type \\(s\\), \\(w_{k}(t)\\) contains the age and gender of the individuals, \\(\\gamma_{s}^{\\prime}\\) measure the sensitivity to age and gender, \\(\\psi(t)\\) is a latent process that captures the uncertainty, and \\(\\alpha_{s}\\) measures the sensitivity to the latent process.</p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#three-models","title":"Three Models","text":""},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#static-model","title":"Static Model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k},\\] <p>where \\(x_k(t)\\) represents the age for the \\(k\\)th individual at time t and \\(F_k = 1\\) if the \\(k\\)th individual is female. The coefficients are parameters to be estimated.</p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#trend-model","title":"Trend Model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i,\\] <p>where \\(i\\) is the index number of the interview indicating the time trend. Note that \\(i=1\\) corresponds to the interview year 1998, and the interview is taken every two years. Therefore, i=(interview year - 1998)/2 + 1.</p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#frailty-model","title":"Frailty Model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i+\\alpha_{s} \\psi_{i},\\] <p>where \\(\\psi_{i}\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi_{i} = \\psi_{i-1} + \\epsilon_{i}\\) with \\(\\epsilon_{i} \\sim \\text{N}(0, 1)\\).</p>"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#parameters","title":"Parameters","text":"<p>The module uses cox hazard model parameters estimated from external research studies. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty</p> <p>The estimated parameters of the static, trend, and frailty models from the above study with the US HRS data are embedded in the module:</p> <ul> <li>US Health and Retirement Study (parameter name: US_HRS_5)</li> </ul>"},{"location":"Health/Multi%20State%20Model/3_state_model/","title":"3-State Model","text":"<p>This module conducts mortality analysis using the 3 state model with the following transitions: </p> <p></p> <p>The three states are: </p> <ul> <li> <p>H: Healthy</p> </li> <li> <p>F: Disabled </p> </li> <li> <p>D: Dead</p> </li> </ul> <p>Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. </p> <p>Functionalities of the module includes:</p> <ul> <li> <p>Calculating transition probability matrices from parameters of Cox Regression model</p> </li> <li> <p>Creating life tables for a certain individual characteristic</p> </li> <li> <p>Simulating lifetime paths </p> </li> <li> <p>Returning key survival statistics for a certain individual </p> </li> </ul> <p>These functions can be helpful in conducting mortality studies, as well as applications in  insurance pricing. </p> <p>The general overview and usage of the module can be seen in the following flowchart: </p> <p></p>"},{"location":"Health/Multi%20State%20Model/5_state_model/","title":"# 5-State Model","text":"<p>This module conducts mortality analysis using the 5 state model with the following transitions: </p> <p></p> <p>The five states are: </p> <ul> <li> <p>H: Healthy and not functionally disabled</p> </li> <li> <p>D: Healthy and functionally disabled</p> </li> <li> <p>M: Ill health and not functionally disabled</p> </li> <li> <p>MD: Ill health and functionally disabled</p> </li> <li> <p>Dead</p> </li> </ul> <p>Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty</p> <p>The transition types are numbered from 1 to 12 illustrated in the table below.</p> <p></p> <p>Functionalities of the module includes:</p> <ul> <li> <p>Calculating transition probability matrices from parameters of Cox Regression model</p> </li> <li> <p>Creating life tables for a certain individual characteristic</p> </li> <li> <p>Simulating lifetime paths </p> </li> <li> <p>Returning key survival statistics for a certain individual </p> </li> </ul> <p>These functions can be helpful in conducting mortality studies, as well as applications in  insurance pricing.</p>"},{"location":"Health/Statistics/stats_3/","title":"3-State Model","text":"<p>A lot of mortality statistics can be generated to analyse survival of a certain individual. The following functions return the expected value and variance associated with the lifetime statistic.</p> <p>The functions can use either of the different inputs below to produce the required statistic:</p> <ul> <li> <p>list of transition probability matrices from <code>get_trans_probs</code></p> </li> <li> <p>simulated path matrix from <code>simulate_health_state_paths</code></p> </li> </ul> <p>If the first option is used, the functions use simulation to find expected value and variance.  Hence, there is a stochastic component to these results. If both inputs are provided, then the simulated path wil be used, and no simulation will occur within the function.</p> <p>Each function comes with a frailty version, which has the same name with an 'F' attached to it (eg.  <code>health3_afl</code> -&gt; <code>health3_aflF</code>). The frailty version simulates 'n' unique latent paths, which adds another level of randomness in the statistic. It also requires the same parameters needed to produce a new set of transition probability matrices (see below examples). By default, frailty functions simulate 1000 unique latent factors. </p> <p>For all code examples below, we will use a male individual aged 65 in year 2022.</p>"},{"location":"Health/Statistics/stats_3/#average-future-lifetime-health3_afl-health3_aflf","title":"Average Future Lifetime: <code>health3_afl</code> (<code>health3_aflF</code>)","text":"<p>The function calculates the average future lifetime for a given individual, and its variance.</p> <p>health3_afl(init_age, init_state, trans_probs = NULL, simulated_path = NULL)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of indiviudal</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> trans_probs : list</p> <p> list of transition probability matrices</p> <p> simulated_path : matrix</p> <p> matrix containing life path simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of average future lifetime</p> <p> Usage:</p> <pre><code># trend model\ntrans_probs &lt;- get_trans_probs(n_states=3, model_type='T', param_file=US_HRS, init_age=65, female=0, year = 2022)\n# calculate average future lifetime\nhealth3_afl(65, init_state = 0, trans_probs)\n</code></pre> <p>health3_aflF(init_age, init_state, female, year, param_file, n = 1000)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of individual</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> female : numeric</p> <p> 0 for male, 1 for female</p> <p> year : numeric</p> <p> numeric denoting current year</p> <p> param_file : character OR dataframe/tibble</p> <p> File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS)</p> <p> n : numeric</p> <p> numeric denoting number of unique latent factor simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of average future lifetime</p> <p> Usage:</p> <pre><code>health3_aflF(65, init_state = 0, female = 0, 2022, US_HRS)\n</code></pre>"},{"location":"Health/Statistics/stats_3/#healthy-future-lifetime-health3_hfl-health3_hflf","title":"Healthy Future Lifetime <code>health3_hfl</code> (<code>health3_hflF</code>)","text":"<p>This function calculates the average future lifetime spent in the healthy state, and its variance.</p> <p>health3_hfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of indiviudal</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> trans_probs : list</p> <p> list of transition probability matrices</p> <p> simulated_path : matrix</p> <p> matrix containing life path simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of healthy future lifetime</p> <p> Usage:</p> <pre><code># trend model\ntrans_probs &lt;- get_trans_probs(n_states=3, model_type='T', param_file=US_HRS, init_age=65, female=0, year = 2022)\n# calculate healthy future lifetime\nhealth3_hfl(65, init_state = 0, trans_probs)\n</code></pre> <p>health3_hflF(init_age, init_state, female, year, param_file, n = 1000)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of indiviudal</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> female : numeric</p> <p> 0 for male, 1 for female</p> <p> year : numeric</p> <p> numeric denoting current year</p> <p> param_file : character OR dataframe/tibble</p> <p> File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS)</p> <p> n : numeric</p> <p> numeric denoting number of unique latent factor simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of healthy future lifetime</p> <p> Usage:</p> <pre><code>health3_hflF(65, init_state = 0, female = 0, 2022, US_HRS)\n</code></pre>"},{"location":"Health/Statistics/stats_3/#average-disabled-future-lifetime-health3_dfl-health3_dflf","title":"Average Disabled Future Lifetime: <code>health3_dfl</code> (<code>health3_dflF</code>)","text":"<p>This function calculates the average future lifetime spent in the disabled state, and its variance.</p> <p>Not that under the same simulated lifetime, average future lifetime is equal to the sum of healthy      lifetime and disabled lifetime. </p> <p>health3_dfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of individual</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> trans_probs : list</p> <p> list of transition probability matrices</p> <p> simulated_path : matrix</p> <p> matrix containing life path simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of average lifetime spent in disabled state</p> <p> Usage:</p> <pre><code># trend model\ntrans_probs &lt;- get_trans_probs(n_states=3, model_type='T', param_file=US_HRS, init_age=65, female=0, year = 2022)\n# calculate average future lifetime in disabled state\nhealth3_dfl(65, init_state = 0, trans_probs)\n</code></pre> <p>health3_dflF(init_age, init_state, female, year, param_file, n = 1000)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of individual</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> female : numeric</p> <p> 0 for male, 1 for female</p> <p> year : numeric</p> <p> numeric denoting current year</p> <p> param_file : character OR dataframe/tibble</p> <p> File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS)</p> <p> n : numeric</p> <p> numeric denoting number of unique latent factor simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of average future lifetime in disabled state</p> <p> Usage:</p> <pre><code>health3_dflF(65, init_state = 0, female = 0, 2022, US_HRS)\n</code></pre>"},{"location":"Health/Statistics/stats_3/#time-until-onset-of-disability-health3_time_to_disabled-health3_time_to_disabledf","title":"Time until onset of Disability: <code>health3_time_to_disabled</code> (<code>health3_time_to_disabledF</code>)","text":"<p>This function calculates average time for onset of disability, given that the  individual becomes disabled. </p> <p>Note that an initial state is not required for this function, as disabled initial state is  trivial. </p> <p>health3_time_to_disabled(init_age, trans_probs = NULL, simulated_path = NULL)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of indiviudal</p> <p> trans_probs : list</p> <p> list of transition probability matrices</p> <p> simulated_path : matrix</p> <p> matrix containing life path simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of onset of first diability</p> <p> Usage:</p> <pre><code># trend model\ntrans_probs &lt;- get_trans_probs(n_states=3, model_type='T', param_file=US_HRS, init_age=65, female=0, year = 2022)\n# calculate time until onset of disability\nhealth3_time_to_disabled(65, trans_probs)\n</code></pre> <p>health3_time_to_disabledF(init_age, female, year, param_file, n = 1000)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of individual</p> <p> female : numeric</p> <p> 0 for male, 1 for female</p> <p> year : numeric</p> <p> numeric denoting current year</p> <p> param_file : character OR dataframe/tibble</p> <p> File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS)</p> <p> n : numeric</p> <p> numeric denoting number of unique latent factor simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of onset of first disability</p> <p> Usage:</p> <pre><code>health3_time_to_disabledF(65, female = 0, 2022, US_HRS)\n</code></pre>"},{"location":"Health/Statistics/stats_3/#all-survival-stats-health3_survival_stats-health3_survival_statsf","title":"All Survival Stats: <code>health3_survival_stats</code> (<code>health3_survival_statsF</code>)","text":"<p>A combination of all the above functions. If transition probabilities are provided, then one simulation is run and all the statistics are calculated from that simulation (this is  to keep results consistent). A simulated pathway can also be provided.</p> <p>Time until onset of disability is not returned if initial state is set to 1 as it is trivial. </p> <p>The function returns all the information (mean and variance of each statistic) as a dataframe.</p> <p>health3_survival_stats(init_age, init_state, trans_probs = NULL, simulated_path = NULL)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of individual</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> trans_probs : list</p> <p> list of transition probability matrices</p> <p> simulated_path : matrix</p> <p> matrix containing life path simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of all statistics</p> <p> Usage:</p> <pre><code># trend model\ntrans_probs &lt;- get_trans_probs(n_states=3, model_type='T', param_file=US_HRS, init_age=65, female=0, year = 2022)\n# calculate all statistics\nhealth3_survival_stats(65, init_state = 0, trans_probs)\n</code></pre> <p>health3_survival_statsF(init_age, init_state, female, year, param_file, n = 1000)</p> <p> Parameters:</p> <p> init_age : numeric</p> <p> numeric denoting initial age of individual</p> <p> init_state : numeric</p> <p> initial state of individual: 0 for healthy, 1 for disabled</p> <p> female : numeric</p> <p> 0 for male, 1 for female</p> <p> year : numeric</p> <p> numeric denoting current year</p> <p> param_file : character OR dataframe/tibble</p> <p> File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS)</p> <p> n : numeric</p> <p> numeric denoting number of unique latent factor simulations</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Mean and variance of all statistics</p> <p> Usage:</p> <pre><code>health3_survival_statsF(65, init_state = 0, female = 0, 2022, US_HRS)\n</code></pre>"},{"location":"Health/Statistics/stats_5/","title":"5-State Model","text":"<p>With the use of simulated paths, a lot of mortality statistics can be generated  to analyse or simply gain insight into the survival characteristics of certain individuals. </p> <p>For the 5 state model, we use the simulated paths as inputs to calculate:</p> <ul> <li> <p>the average time of entering a certain state (such as the D state: Healthy and functionally disabled)</p> </li> <li> <p>the total time spent in each state </p> </li> </ul> <p>As results are stochastic (statistics are derived from random simulated lifetimes), we can  also study the variance of these statistics. This will be beneficial in quantifying the risk,  allowing for more robust pricing methods. </p>"},{"location":"Health/Statistics/stats_5/#average-first-time-entering-state","title":"Average First Time Entering State","text":"<p>health5_first_time_stats(simulated_path, state)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 simulated_path : matrix</p> <p> matrix containing life time simulations, obtained from function \"simulate_health_state_paths\"</p> <p>\u00a0\u00a0\u00a0\u00a0 state : numeric</p> <p> integer denoting which state we are entering or leaving</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 0 for first time leaving H state, only used when initial state is 0</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 1 for first time entering M state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 2 for first time entering D state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 3 for first time entering MD state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -1 for first time entering the dead state</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 column vector of first time entering the specified state</p> <p> Usage:</p> <pre><code># simulation of 10000 males aged 65 initially healthy under the trend model\ntrans_probs &lt;- get_trans_probs(n_states=5, model_type='T', param_file=US_HRS_5, init_age=65, female=0, year = 2012, wave_index = 8, latent = 0)\nsimulated_path &lt;- simulate_health_state_paths(trans_probs, init_age=65, init_state = 0, cohort = 10000)\n# time until entering M state, ill health but not functionally disabled\ntime_to_M &lt;- health5_first_time_stats(simulated_path, 1)\n# average initial time of entering state 1\nprint(mean(time_to_M, na.rm = TRUE))\n</code></pre>"},{"location":"Health/Statistics/stats_5/#total-time-spent-in-state","title":"Total Time Spent in State","text":"<p>health5_total_time_stats(simulated_path, state)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 simulated_path : matrix</p> <p> matrix containing life time simulations, obtained from function \"simulate_health_state_paths\"</p> <p>\u00a0\u00a0\u00a0\u00a0 state : numeric</p> <p> integer denoting which state we are counting</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 0 for total time in H state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 1 for total time in M state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 2 for total time in D state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 3 for total time in MD state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 -1 for total time in dead state</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 4 for total time alive or not in dead state</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 column vector of total times spent in specified state</p> <p> Usage:</p> <pre><code># simulation of 10000 males aged 65 initially healthy under the trend model\ntrans_probs &lt;- get_trans_probs(n_states=5, model_type='T', param_file=US_HRS_5, init_age=65, female=0, year = 2012, wave_index = 8, latent = 0)\nsimulated_path &lt;- simulate_health_state_paths(trans_probs, init_age=65, init_state = 0, cohort = 10000)\n# total time spent in MD state, ill health and functionally disabled \ntotal_state_MD &lt;- health5_total_time_stats(simulated_path, 3)\n# average time spent in state MD\nprint(mean(total_state_MD))\n</code></pre>"},{"location":"Health/Statistics/stats_5/#produce-mean-and-variance-from-output","title":"Produce Mean and Variance from Output","text":"<p>This function is a 'helper' function, used in conjunction with the ouput of the  previous functions to create the mean and variance of those statistics. </p> <p>health5_stats_produce(input)</p> <p> Parameters:</p> <p>\u00a0\u00a0\u00a0\u00a0 input : matrix</p> <p> n\\(\\times\\)1 matrix of statistics</p> <p> Returns</p> <p>\u00a0\u00a0\u00a0\u00a0 mean and variance of the statistics inputted</p> <p> Usage:</p> <pre><code># simulation of 10000 males aged 65 initially healthy under the trend model\ntrans_probs &lt;- get_trans_probs(n_states=5, model_type='T', param_file=US_HRS_5, init_age=65, female=0, year = 2012, wave_index = 8, latent = 0)\nsimulated_path &lt;- simulate_health_state_paths(trans_probs, init_age=65, init_state = 0, cohort = 10000)\n# time until entering M state, ill health but not functionally disabled\ntime_to_M &lt;- health5_first_time_stats(simulated_path, 1)\n# total time spent in MD state, ill health and functionally disabled \ntotal_time_state_MD &lt;- health5_total_time_stats(simulated_path, 3)\n# produce mean and variance of first time into M state\nfirst_time_M_stats &lt;- health5_stats_produce(time_to_M)\n# produce mean and variance of time spent in MD state\ntotal_time_in_MD_stats &lt;- health5_stats_produce(total_time_state_MD)\n</code></pre>"},{"location":"Home/about/","title":"About","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"Home/about/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"Home/about/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Home/log/","title":"Changelog","text":""},{"location":"Home/start/","title":"Getting Started","text":""},{"location":"Home/start/#installation","title":"Installation","text":"<ol> <li>Clone repository or download ZIP </li> <li>In RStudio: <pre><code>File &gt; Open project &gt; /rit-main\n</code></pre></li> <li>In RStudio Console:  <pre><code>install.packages(\"devtools\")\nlibrary(\"devtools\")\nload_all(export_all = FALSE)\n</code></pre></li> </ol>"},{"location":"Home/start/#demo","title":"Demo","text":"<p>Visit <code>demo/</code> directory to find example workflows for each module.</p>"},{"location":"Policy%20Valuation/cashflow/","title":"Simulating Cashflows","text":"<p>Simulate cash flows using Monte-Carlo methods for a given policy. Function  will use generated mortality, health state and economic variables to generate cashflows for n different pathways. This can be used either directly for calculations,  or passed into the value_policy function for pricing statistics.</p> <p>Note</p> <p>For each policy, the benefit paid at each time period is defined as below:</p> <ul> <li>Account Based Pension: If the policyholder is alive, pays the inflation-adjusted expense. If the benefit exceeds the remaining balance, the remaining balance is paid. Otherwise, no benefit is paid.</li> <li>Life Annuity: If the deferment period has elapsed and policyholder is alive, pays benefit after flat-rate increase adjustment. Otherwise, no benefit is paid.</li> <li>Care Annuity: If policyholder is alive or minimum guaranteed period is still active, pays sum of all benefits a policyholder is eligible for under LTC after flat-rate increase adjustment. Otherwise, no benefit is paid.</li> <li>Variable Annuity: If policyholder is alive, pays benefit of the maximum withdrawal amount permissible under the contract. If the benefit exceeds the remaining balance, the remaining balance is paid. Otherwise, no benefit is paid.</li> <li>Pooled Annuity: If the policyholder is alive, pays benefit after factoring mortality experience adjustment \\((p_{x+t}/p_{x+t}^*)\\) and interest rate adjustment \\((1+r_{x+t}^*)/(1+r_{x+t})\\). Otherwise, no benefit is paid.</li> <li>Reverse Mortgage: If the policyholder dies during the time period, pays the surplus of the loan value deducted by house value after adjusting for cost-of-sale. If the surplus is negative or policyholder doesn't die during period, no benefit is paid.</li> </ul> <p>simulate_cf(policy, age, sex, seed, n)</p> <p> Parameters:</p> <p> policy : Policy object </p> <p> Policy object generated from create_policy function (see  Creating Policy Object)</p> <p> age : numeric</p> <p> Initial age of policyholder in years</p> <p> sex : character</p> <p> sex = \"F\" (female), \"M\" (male)</p> <p> seed : numeric</p> <p> Random seed used for RNG</p> <p> n : numeric</p> <p> Number of paths to simulate (Monte-Carlo method)</p> <p> state : matrix</p> <p> Matrix of health states for \\(n\\) pathways over \\(m\\) periods (see Health State / Mortality)</p> <p> econ_var : list</p> <p> List of matrices for each economic variables required by the chosen policy, these include: </p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 - $sdf: stochastic discount factor -&gt; required by All Policies</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 - $infla: inflation index -&gt; required by Account Based Pension</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 - $stock: stock price -&gt; required by Account Based Pension, Pooled Annuity, Variable Annuity</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 - $zcp3m: zero-coupon bond yield (3-month) -&gt; required by Reverse Mortgage</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 - $house: house price -&gt; required by Reverse Mortgage</p> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (see Economic Scenario Generator for example implementation)</p> <p> Returns:</p> <p> SimCashflow object </p> <p> Usage: <pre><code>ap &lt;- create_policy_AP(400000, 60000)\ncf &lt;- simulate_cf(policy = ap, age = 65, sex = \"M\", n = 1000)\n</code></pre></p> <p>Note</p> <p>state &amp; econ_var use \\(n \u00d7 m\\) matrices, where \\(n\\) is the number of simulated paths and \\(m\\) is the number of periods. Any periodicity can be used as long as all matrices are consistent, i.e. each time-step can represent a month, year, or other length (simulation defaults to annual period).</p> <p>Note</p> <p>Economic variables needed by each policy:</p> <ul> <li>Account Based Pension: requires stochastic discount factors ($sdf), inflation rate ($infla) &amp; investment return ($stock).</li> <li>Life Annuity: requires stochastic discount factors ($sdf).</li> <li>Care Annuity: requires stochastic discount factors ($sdf).</li> <li>Variable Annuity: requires stochastic discount factors ($sdf), investment return ($stock).</li> <li>Pooled Annuity: requires stochastic discount factors ($sdf), investment return ($stock).</li> <li>Reverse Mortgage: requires stochastic discount factors ($sdf), 3-month zero-coupon bond yield ($zcp3m) &amp; change in house price ($house).</li> </ul> <p> SimCashflow</p> <p> Attributes:</p> <p> cf : Matrix </p> <p> Simulated cashflows for each pathway at every time step</p> <p> sdf : Matrix</p> <p> Stochastic discount factors for each pathway at every time step</p> <p>Note</p> <p>cf &amp; sdf are \\(n \u00d7 m\\) matrices, where \\(n\\) is the number of simulated paths and \\(m\\) is the number of periods.</p>"},{"location":"Policy%20Valuation/overview/","title":"Overview","text":"<p>This module takes input aggregate mortality scenarios, functional disability/health status scenarios,  economic scenarios to simulate cash flows on retirement products.</p> <p>Retirement products include:</p> <ul> <li>Account-based pensions</li> <li>Life annuities</li> <li>Deferred life annuities</li> <li>Pooled annuities</li> <li>Long-term care insurance</li> <li>Care annuities</li> <li>Variable annuities with GMWB</li> <li>Reverse mortgages with NNEG</li> </ul> <p>Risk-adjusted expected cash flows are computed, and prices are determined based on relevant assumptions.  Models use Australian data for Australian applications. The module includes government age pension  and aged care based on current means-testing.</p>"},{"location":"Policy%20Valuation/policy/","title":"Creating Policy Object","text":"<p>To begin, we need to initialise a policy object which contains all  relevant parameters describing the policy.</p>"},{"location":"Policy%20Valuation/policy/#functions","title":"Functions","text":"<ul> <li><code>create_policy_AP</code> - Account Based Pension</li> <li><code>create_policy_RM</code> - Reverse Mortgage</li> <li><code>create_policy_LA</code> - Life Annuity</li> <li><code>create_policy_PA</code> - Pooled Annuity</li> <li><code>create_policy_CA</code> - Care Annuity (LTC)</li> <li><code>create_policy_VA</code> - Variable Annuity (GMWB)</li> </ul>"},{"location":"Policy%20Valuation/policy/#account-based-pension","title":"Account Based Pension","text":"<p>create_policy_AP(balance, expenses)</p> <p> Parameters:</p> <p> balance : numeric </p> <p> Initial balance of Pension account</p> <p> expenses : numeric</p> <p> Initial yearly expenses for policyholder</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Policy object</p> <p> Usage:</p> <pre><code>ap &lt;- create_policy_AP(400000, 60000)\n</code></pre> <p></p>"},{"location":"Policy%20Valuation/policy/#reverse-mortgage-nneg","title":"Reverse Mortgage (NNEG)","text":"<p>create_policy_RM(value, LVR, trans_cost, margin)</p> <p> Parameters:</p> <p> value : numeric </p> <p> Initial value of property</p> <p> LVR : numeric</p> <p> Loan to Value ratio for PH</p> <p> trans_cost : numeric</p> <p> Transaction cost associated with sale</p> <p> margin : numeric</p> <p> Lending margin</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Policy object</p> <p> Usage:</p> <pre><code>rm &lt;- create_policy_RM(100000, 0.4, 0.01, 0.05)\n</code></pre> <p></p>"},{"location":"Policy%20Valuation/policy/#life-annuity","title":"Life Annuity","text":"<p>create_policy_LA(benefit, defer = 0, increase = 0)</p> <p> Parameters:</p> <p> benefit : numeric </p> <p> Annual benefit for policy</p> <p> defer : numeric</p> <p> (Optional) Deferment period of policy</p> <p> increase : numeric</p> <p> (Optional) Annual rate of increase for policy</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Policy object</p> <p> Usage:</p> <pre><code>la &lt;- create_policy_LA(60000, 5, 0.04, 0.05)\n</code></pre> <p></p>"},{"location":"Policy%20Valuation/policy/#care-annuity-ltc","title":"Care Annuity (LTC)","text":"<p>Note</p> <p>Care annuities are evaluated based on the 3-State or 5-State model  outlined in the Health State module. Parameters should be vectors of length 2 or 4 (as no benefits paid whilst PH is dead, policies are only characterized by  remaining states).</p> <p>create_policy_CA(benefit, increase, min)</p> <p> Parameters:</p> <p> benefit : vector </p> <p> Annual benefit for each policy</p> <p> increase : vector</p> <p> Annual rate of increase for each policy</p> <p> min : vector</p> <p> Minimum guaranteed period for each policy</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Policy object</p> <p> Usage:</p> <pre><code>ca &lt;- create_policy_CA(c(60000, 1200), c(0, 0.04), c(8, 0), c(0.04, 0.05))\n</code></pre> <p></p>"},{"location":"Policy%20Valuation/policy/#pooled-annuity","title":"Pooled Annuity","text":"<p>create_policy_PA(benefit, size, interest)</p> <p> Parameters:</p> <p> benefit : numeric </p> <p> Initial annual benefit for policy</p> <p> size : numeric</p> <p> Size of pool</p> <p> interest : numeric</p> <p> Assumed investment earnings rate (flat)</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Policy object</p> <p> Usage:</p> <pre><code>pa &lt;- create_policy_PA(60000, 1000, 0.04, 0.05)\n</code></pre> <p></p>"},{"location":"Policy%20Valuation/policy/#variable-annuity-gmwb","title":"Variable Annuity (GMWB)","text":"<p>create_policy_VA(value, length, prop, g_fee) </p> <p> Parameters:</p> <p> value : numeric </p> <p> Initial Account value (single upfront premium)</p> <p> length : numeric</p> <p> Length of contract (in years)</p> <p> prop : numeric </p> <p> Proportion of the premium that can be withdrawn annually</p> <p> g_fee : numeric</p> <p> Continuous guarantee fees for GMWB</p> <p> Returns:</p> <p>\u00a0\u00a0\u00a0\u00a0 Policy object</p> <p> Usage:</p> <pre><code>va &lt;- create_policy_VA(100000, 40, 0.4, 0.02)\n</code></pre>"},{"location":"Policy%20Valuation/pricing/","title":"Valuation","text":"<p>Conducts valuation of a given policy, providing summary statistic &amp; plots on the total discounted value of all cashflows received by each pathway.</p> <p>value_policy(policy, cashflows, seed)</p> <p> Parameters:</p> <p> policy : Policy object </p> <p> Policy object generated from create_policy function (see Creating Policy Object)</p> <p> cashflows : Matrix</p> <p> Matrix of cashflows generated from simulate_cf function (see Simulating Cashflows)</p> <p> seed : numeric</p> <p> Random seed used for random sampling</p> <p> Returns:</p> <p> PolStats object</p> <p> Usage: <pre><code>&gt; ap &lt;- create_policy_AP(400000, 60000)\n&gt; cf &lt;- simulate_cf(policy = ap, age = 65, sex = \"M\", n = 1000)\n&gt; v &lt;- value_policy(ap, cf)\n========= Policy Details =========\nType        : Account Based Policy\n----------------------------------\nBalance     : 4e+05\nExpense     : 60000\n======= Summary Statistics =======\nMean        : $343,583.95\nStd Dev     : $39,612.09\n----------------------------------\nMinimum     : $55,283.93\nMaximum     : $590,965.62\n----------------------------------\nP_0.25      : $316,733.50\nP_0.50      : $339,143.08\nP_0.75      : $365,797.98\nP_0.95      : $413,909.46\nP_0.99      : $455,971.51\n----------------------------------\nSkewness    : 0.44\nKurtosis    : 5.47\n==================================\n</code></pre></p> <p> PolStats</p> <p> Attributes:</p> <p> paths : Vector </p> <p> Valuation of individual cashflows by path</p> <p> stats : List</p> <p> Summary statistics of discounted cashflow</p> <p> conv : Plot</p> <p> Convergence plot of simulation using random sampling</p> <p> dist : Plot</p> <p> Distribution plot of present value by path</p> <p> scat : Plot</p> <p> Scatter plot of present value by path</p>"},{"location":"Policy%20Valuation/workflow/","title":"Workflow Example","text":""},{"location":"Policy%20Valuation/workflow/#default-behaviour","title":"Default Behaviour","text":"<pre><code># Account-Based Pension\nap &lt;- create_policy_AP(1000000, 50000)\ncf_ap &lt;- simulate_cf(ap)\nval_ap &lt;- value_policy(ap, cf_ap)\n# Life Annuity\nla &lt;- create_policy_LA(60000, 5, 0, 0.01)\ncf_la &lt;- simulate_cf(la)\nval_la &lt;- value_policy(la, cf_la)\n# Pooled Annuity\npa &lt;- create_policy_PA(60000, 10000, 0.05, 0.01)\ncf_pa &lt;- simulate_cf(pa)\nval_pa &lt;- value_policy(pa, cf_pa)\n# Care Annuity\nca &lt;- create_policy_CA(c(60000, 1200), c(0, 0.04), c(5, 0), c(0.04, 0.01))\ncf_ca &lt;- simulate_cf(ca)\nval_ca &lt;- value_policy(ca, cf_ca)\n# Reverse Mortgage\nrm &lt;- create_policy_RM(600000, 0.64, 0.01, 0.04)\ncf_rm &lt;- simulate_cf(rm)\nval_rm &lt;- value_policy(rm, cf_rm)\n# Variable Annuity (GMWB)\nva &lt;- create_policy_VA(1000000, 30, 0.1, 0.01)\ncf_va &lt;- simulate_cf(va)\nval_va &lt;- value_policy(va, cf_va)\n</code></pre>"},{"location":"Policy%20Valuation/workflow/#customised-behaviour","title":"Customised Behaviour","text":""},{"location":"Policy%20Valuation/workflow/#example-1-life-annuity-where-nth-policyholder-dies-in-year-n","title":"Example 1: Life annuity where n'th policyholder dies in year n","text":"<pre><code>construct_state_matrix &lt;- function(ages_at_death, max_years) {\nn_paths &lt;- length(ages_at_death)\n# Create matrix with all entries = -1 (i.e. PH is dead)\nstate &lt;- matrix(rep(-1, n_paths*max_years), nrow=n_paths,\nncol=max_years, byrow=TRUE)\nfor (i in seq(1, n_paths)) {\n# Set all entries in i'th row prior to death as 0 (i.e. PH is alive)\ndeath_yr &lt;- ages_at_death[i]\nstate[i, 1:death_yr] &lt;- rep(0, death_yr)\n}\nreturn(state)\n}\n# Construct state matrix\nages_at_death = seq(1, 100)\nstate &lt;- construct_state_matrix(ages_at_death, max_years = 100)\n# Create list of relevant economic variables\nsdf &lt;- matrix(rep(1.06, N_PATHS*MAX_YEARS),\nnrow=100,\nncol=100,\nbyrow=TRUE)\necon_var &lt;- list(sdf=sdf)\nla &lt;- create_policy_LA(1, defer = 0, increase = 0)\ncf_la &lt;- simulate_cf(la, n = 100, state = state, econ_var = econ_var)\nval_la &lt;- value_policy(la, cf_la)\n</code></pre>"},{"location":"Policy%20Valuation/workflow/#example-2-life-annuity-using-life-tables-from-lifecontingencies","title":"Example 2: Life annuity using life tables from 'lifecontingencies'","text":"<pre><code>construct_state_matrix &lt;- function(ages_at_death, max_years) {\nn_paths &lt;- length(ages_at_death)\n# Create matrix with all entries = -1 (i.e. PH is dead)\nstate &lt;- matrix(rep(-1, n_paths*max_years), nrow=n_paths,\nncol=max_years, byrow=TRUE)\nfor (i in seq(1, n_paths)) {\n# Set all entries in i'th row prior to death as 0 (i.e. PH is alive)\ndeath_yr &lt;- ages_at_death[i]\nstate[i, 1:death_yr] &lt;- rep(0, death_yr)\n}\nreturn(state)\n}\nget_ages_at_death &lt;- function(surv_probs, max_years, n_paths) {\nages_at_death &lt;- c()\nfor (i in seq(1, n_paths)) {\np &lt;- stats::runif(length(surv_probs))\nlv &lt;- min(which((p &gt; surv_probs) == TRUE))\nages_at_death &lt;- c(ages_at_death, lv)\n}\nreturn(ages_at_death)\n}\nget_px_from_lx &lt;- function(lx) {\npx &lt;- lx\npx[1] &lt;- 1\nfor (i in seq(2, length(lx) - 1)) {\npx[i] &lt;- 1 - (lx[i] - lx[i+1])/lx[i]\n}\npx[length(lx)] &lt;- 0\nreturn(px)\n}\nlibrary(lifecontingencies); data(soaLt);\ninitial_age &lt;- 65\nsoa08Act &lt;- with(soaLt, new(\"actuarialtable\",interest=0.06,\nx=x,lx=Ix,name=\"SOA2008\"))\nlx08 &lt;- soa08Act@lx[initial_age + 1:length(soa08Act@lx)]\n# Extract survival probabilities from soa0xAct\nsurv &lt;- extract_px_from_lx(lx08)\n# Simulate ages at death based on survival probabilities\ndeath_ages &lt;- get_ages_at_death(surv, 100, 100)\n# Construct state matrix\nstate &lt;- construct_state_matrix(death_ages, max_years = 100)\nla &lt;- create_policy_LA(1, defer = 0, increase = 0)\ncf_la &lt;- simulate_cf(la, n = 100, state = state)\nval_la &lt;- value_policy(la, cf_la)\n</code></pre>"}]}